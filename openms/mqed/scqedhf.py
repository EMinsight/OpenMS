#
# @ 2023. Triad National Security, LLC. All rights reserved.
#
# This program was produced under U.S. Government contract 89233218CNA000001
# for Los Alamos National Laboratory (LANL), which is operated by Triad
# National Security, LLC for the U.S. Department of Energy/National Nuclear
# Security Administration. All rights in the program are reserved by Triad
# National Security, LLC, and the U.S. Department of Energy/National Nuclear
# Security Administration. The Government is granted for itself and others acting
# on its behalf a nonexclusive, paid-up, irrevocable worldwide license in this
# material to reproduce, prepare derivative works, distribute copies to the
# public, perform publicly and display publicly, and to permit others to do so.
#
# Author: Yu Zhang <zhy@lanl.gov>
#

import sys
import copy
import numpy
from openms import __config__
from pyscf import lib
from pyscf.scf import hf
from pyscf.dft import rks
#from openms.lib      import logger

from pyscf.lib import logger
from openms.mqed import diis
from pyscf.scf import addons
from pyscf.scf import chkfile
from pyscf import __config__
from scipy import linalg

from openms.lib.scipy_helper import partial_cholesky_orth_, pivoted_cholesky
from openms.lib.scipy_helper import remove_linear_dep
from functools import reduce
import time

TIGHT_GRAD_CONV_TOL = getattr(__config__, "scf_hf_kernel_tight_grad_conv_tol", True)
LINEAR_DEP_THRESHOLD = getattr(__config__, 'scf_addons_remove_linear_dep_threshold', 1e-8)
CHOLESKY_THRESHOLD = getattr(__config__, 'scf_addons_cholesky_threshold', 1e-10)
LINEAR_DEP_TRIGGER = getattr(__config__, 'scf_addons_remove_linear_dep_trigger', 1e-10)
FORCE_PIVOTED_CHOLESKY = getattr(__config__, 'scf_addons_force_cholesky', False)


r"""
Theoretical background of SC/VT-QEDHF methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SC-QEDHF module for solving the QED Hamiltonian. The kernel is also used for VT-QEDHF.

Energy within SC-QEDHF formalism:

.. math::

  E = \sum_{pq} h_{pq} D_{pq} G_{pq} + \cdots


"""

# scqed kernel
def kernel(mf, conv_tol=1e-10, conv_tol_grad=None,
           dump_chk=True, dm0=None, callback=None, conv_check=True, **kwargs):
    '''kernel: the SC-QEDHF and VT-QEDHF SCF driver.

    The major difference against hf kernel is that the one-body and two-body
    integrals are dressed by the photon displacement factors
    and addtional variational parameters eta (for relaxting dipole basis set)
    and variational transformation f are introduced.

    Args:
        mf : an instance of SCF class
            mf object holds all parameters to control SCF.  One can modify its
            member functions to change the behavior of SCF.  The member
            functions which are called in kernel are

            | mf.get_init_guess
            | mf.get_hcore
            | mf.get_ovlp
            | mf.get_veff
            | mf.get_fock
            | mf.get_grad
            | mf.eig
            | mf.get_occ
            | mf.make_rdm1
            | mf.energy_tot
            | mf.dump_chk

    Kwargs:
        conv_tol : float
            converge threshold.
        conv_tol_grad : float
            gradients converge threshold.
        dump_chk : bool
            Whether to save SCF intermediate results in the checkpoint file
        dm0 : ndarray
            Initial guess density matrix.  If not given (the default), the kernel
            takes the density matrix generated by ``mf.get_init_guess``.
        callback : function(envs_dict) => None
            callback function takes one dict as the argument which is
            generated by the builtin function :func:`locals`, so that the
            callback function can access all local variables in the current
            environment.

    Returns:
        A list :   scf_conv, e_tot, mo_energy, mo_coeff, mo_occ

        scf_conv : bool
            True means SCF converged
        e_tot : float
            Hartree-Fock energy of last iteration
        mo_energy : 1D float array
            Orbital energies.  Depending the eig function provided by mf
            object, the orbital energies may NOT be sorted.
        mo_coeff : 2D array
            Orbital coefficients.
        mo_occ : 1D array
            Orbital occupancies.  The occupancies may NOT be sorted from large
            to small.

    Examples:

    >>> from pyscf import gto, scf
    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1', basis='cc-pvdz')
    >>> conv, e, mo_e, mo, mo_occ = scf.hf.kernel(scf.hf.SCF(mol), dm0=numpy.eye(mol.nao_nr()))
    >>> print('conv = %s, E(HF) = %.12f' % (conv, e))
    conv = True, E(HF) = -1.081170784378
    '''
    if 'init_dm' in kwargs:
        raise RuntimeError('''You see this error message because of the API
        updates in pyscf v0.11. Keyword argument "init_dm" is replaced by "dm0"''')
    cput0 = (logger.process_clock(), logger.perf_counter())
    if conv_tol_grad is None:
        conv_tol_grad = numpy.sqrt(conv_tol)
        logger.info(mf, 'Set gradient conv threshold to %g', conv_tol_grad)

    mol = mf.mol
    s1e = mf.get_ovlp(mol)
    if dm0 is None:
        dm = mf.get_init_guess(mol, mf.init_guess)
    else:
        dm = dm0

    # get a initial dm without qed terms
    bare_hf = hf.RHF(mol)

    h1e = bare_hf.get_hcore(mol)
    vhf = bare_hf.get_veff(mol, dm)
    e_tot = mf.energy_tot(dm, h1e, vhf)
    logger.info(mf, 'init E= %.15g', e_tot)

    mo_energy, mo_coeff =  cholesky_diag_fock_rao(mf, h1e+vhf)
    mo_occ = mf.get_occ(mo_energy, mo_coeff)
    dm = mf.make_rdm1(mo_coeff, mo_occ)
    #logger.debug(mf, "trace of ao_density: %.8f", numpy.trace(dm))

    if mf.qed.use_cs:
        mf.qed.update_cs(dm)

    if mf.eta is None:
        mf.initialize_bare_fock(dm)
        mf.initialize_eta(dm)

    # construct h1e, gmat in DO representation (used in SC/VT-QEDHF)
    mf.get_h1e_DO(mol, dm=dm)


    h1e = mf.get_hcore(mol, dm, dress=True)
    vhf = mf.get_veff(mol, dm)
    e_tot = mf.energy_tot(dm, h1e, vhf)
    logger.info(mf, 'init E= %.15g', e_tot)

    scf_conv = False
    mo_energy = mo_coeff = mo_occ = None

    s1e = mf.get_ovlp(mol)
    cond = lib.cond(s1e)
    logger.debug(mf, 'cond(S) = %s', cond)
    if numpy.max(cond)*1e-17 > conv_tol:
        logger.warn(mf, 'Singularity detected in overlap matrix (condition number = %4.3g). '
                    'SCF may be inaccurate and hard to converge.', numpy.max(cond))

    # Skip SCF iterations. Compute only the total energy of the initial density
    if mf.max_cycle <= 0:
        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ

    if isinstance(mf.diis, lib.diis.DIIS):
        mf_diis = mf.diis
    elif mf.diis:
        assert issubclass(mf.DIIS, lib.diis.DIIS)
        mf_diis = mf.DIIS(mf, mf.diis_file)
        mf_diis.space = mf.diis_space
        mf_diis.rollback = mf.diis_space_rollback

        # We get the used orthonormalized AO basis from any old eigendecomposition.
        # Since the ingredients for the Fock matrix has already been built, we can
        # just go ahead and use it to determine the orthonormal basis vectors.
        fock = mf.get_fock(h1e, s1e, vhf, dm)
        _, mf_diis.Corth = mf.eig(fock, s1e)
    else:
        mf_diis = None

    if dump_chk and mf.chkfile:
        # Explicit overwrite the mol object in chkfile
        # Note in pbc.scf, mf.mol == mf.cell, cell is saved under key "mol"
        chkfile.save_mol(mol, mf.chkfile)

    # A preprocessing hook before the SCF iteration
    mf.pre_kernel(locals())

    cput1 = logger.timer(mf, 'initialize scf', *cput0)

    for cycle in range(mf.max_cycle):
        time0 = time.time()
        dm_last = dm
        last_hf_e = e_tot

        time1 = time.time()
        # update h1e in DO
        mf.get_h1e_DO(mol, dm=dm)
        time_h1e_do = time.time() - time1

        # compute gradient of eta
        time1 = time.time()
        mf.get_var_gradient(mf.dm_do, mf.g_dipole, dm=dm)
        time_etagrad = time.time() - time1

        # use DIIS to update eta (in get_fock)
        time1 = time.time()
        h1e = mf.get_hcore(mol, dm, dress=True)
        time_hcore = time.time() - time1

        time1 = time.time()
        fock = mf.get_fock(h1e, s1e, vhf, dm, cycle, mf_diis)
        time_fock = time.time() - time1

        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        dm = mf.make_rdm1(mo_coeff, mo_occ)

        # update energy
        time1 = time.time()
        vhf = mf.get_veff(mol, dm, dm_last, vhf)
        time_veff = time.time() - time1

        h1e = mf.get_hcore(mol, dm, dress=True)
        e_tot = mf.energy_tot(dm, h1e, vhf)

        # Here Fock matrix is h1e + vhf, without DIIS.  Calling get_fock
        # instead of the statement "fock = h1e + vhf" because Fock matrix may
        # be modified in some methods.
        time1 = time.time()
        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        time_fock += time.time() - time1

        norm_gorb = linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))
        if not TIGHT_GRAD_CONV_TOL:
            norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)
        norm_eta = mf.get_var_norm()
        norm_gorb += norm_eta

        norm_ddm = linalg.norm(dm-dm_last)
        logger.info(mf, '\ncycle= %d E= %.15g  delta_E= %4.3g  |g|= %4.3g  |g_var|= %4.3g  |ddm|= %4.3g',
                    cycle+1, e_tot, e_tot-last_hf_e, norm_gorb, norm_eta, norm_ddm)
        logger.debug(mf, "cycle= %d times: h1e_do = %.6g eta_grad = %.6g hcore = %.6g veff = %.6g  fock = %.6g scf = %.6g",
                    cycle+1, time_h1e_do, time_etagrad, time_hcore, time_veff, time_fock, time.time()-time0)

        if callable(mf.check_convergence):
            scf_conv = mf.check_convergence(locals())
        elif abs(e_tot-last_hf_e) < conv_tol and norm_gorb < conv_tol_grad:
            scf_conv = True

        if dump_chk:
            mf.dump_chk(locals())

        if callable(callback):
            callback(locals())

        cput1 = logger.timer(mf, 'cycle= %d'%(cycle+1), *cput1)

        if scf_conv:
            break

    if scf_conv and conv_check:
        # An extra diagonalization, to remove level shift
        #fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        dm, dm_last = mf.make_rdm1(mo_coeff, mo_occ), dm
        vhf = mf.get_veff(mol, dm, dm_last, vhf)

        h1e = mf.get_hcore(mol, dm, dress=True)
        e_tot, last_hf_e = mf.energy_tot(dm, h1e, vhf), e_tot

        fock = mf.get_fock(h1e, s1e, vhf, dm)
        norm_gorb = linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))
        if not TIGHT_GRAD_CONV_TOL:
            norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)
        norm_ddm = linalg.norm(dm-dm_last)

        conv_tol = conv_tol * 10
        conv_tol_grad = conv_tol_grad * 3
        if callable(mf.check_convergence):
            scf_conv = mf.check_convergence(locals())
        elif abs(e_tot-last_hf_e) < conv_tol or norm_gorb < conv_tol_grad:
            scf_conv = True
        logger.info(mf, 'Extra cycle  E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',
                    e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)
        if dump_chk:
            mf.dump_chk(locals())

    logger.timer(mf, 'scf_cycle', *cput0)
    # A post-processing hook before return
    mf.post_kernel(locals())
    return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ


def unitary_transform(U, A):
    r"U^T A U"
    B = numpy.einsum("ik, kj->ij", A, U)
    B = numpy.einsum("ki, kj->ij", U, B)
    return B

def ao2rao(A_ao, P):
    r"""Transforms a matrix from the AO basis to the reduced AO (RAO) basis

    .. math::

       A_{RAO} = P^T A_{AO} P

    where P is the projection onto the linarly independent AO basis
    """

    AP = numpy.einsum("ik, kj->ij", A_ao, P)
    A_rao = numpy.einsum("ik, kj->ij", P.conj().T, AP)
    del AP
    return A_rao

def get_reduced_overlp(L):
    r"""

    .. math::

       S_rao = L L^T

    """
    return numpy.einsum("ik, kj->ij", L, L.conj().T)

def ao2oao(A_ao, X):
    r"""
    Transform a matrix from AO to OAO (orthonormal AO) basis

    .. math::
       A_{OAO} = L^{-1} P^T A_{AO} P L^{-T}
               = X^H A_{AP} X

    where :math:`X^T X = S` and :math:`X` is obtaine from the Cholesky
    decomposition of the AO overlap matrix :math:`S`.

    where .. math::

       P^T S P = L L^T

    is the Cholesky decomposition of the atomic overlap matrix :math:`S`.
    """

    A_oao = reduce(lib.dot, (X.conj().T, A_ao, X))
    return A_oao

def oao2ao(A_oao, X):
    r"""
    Transform a matrix from OAO to AO
    """

    Xinv = linalg.inv(X)
    A_ao = reduce(lib.dot, (Xinv.conj().T, A_oao, Xinv))
    return A_ao

def eigh(h, s):
    '''Solver for generalized eigenvalue problem

    .. math:: HC = SCE
    '''
    e, c = linalg.eigh(h, s)
    #idx = numpy.argsort(e)
    #e = e[idx]
    #c = c[:, idx]
    idx = numpy.argmax(abs(c.real), axis=0)
    c[:,c[idx,numpy.arange(len(e))].real<0] *= -1
    return e, c

def get_orbitals_from_oao(c, P, L):
    r"""
    Sets the orbital coefficients from the orbital coefficients in OAO

       orbital_coefficients = P L^-T C
    """
    X = L.copy()
    X = linalg.inv(X)
    Y = numpy.einsum("ik, kj->ij", X.T, c)
    return numpy.einsum("ik, ij->ij", P, Y)

def get_orbitals_from_rao(c, P):
    r"""
    Sets the orbital coefficients from the orbital coefficients in RAO
       orbital_coefficients = P C
    """
    return numpy.einsum("ik, kj->ij", P, c)

def cholesky_diag_fock_rao(mf, h1e):
    r"""
    Diagonalize the Fock matrix in RAO basis
    """
    F_rao = ao2rao(h1e, mf.P)
    S_rao = get_reduced_overlp(mf.L)
    mo_energy, mo_coeff = eigh(F_rao, S_rao)
    mo_coeff = get_orbitals_from_rao(mo_coeff, mf.P)

    return mo_energy, mo_coeff


def get_fock(
    mf,
    h1e=None,
    s1e=None,
    vhf=None,
    dm=None,
    cycle=-1,
    diis=None,
    diis_start_cycle=None,
    level_shift_factor=None,
    damp_factor=None,
):
    """F = h^{core} + V^{HF}

    Special treatment (damping, DIIS, or level shift) will be applied to the
    Fock matrix if diis and cycle is specified (The two parameters are passed
    to get_fock function during the SCF iteration)

    Kwargs:
        h1e : 2D ndarray
            Core hamiltonian
        s1e : 2D ndarray
            Overlap matrix, for DIIS
        vhf : 2D ndarray
            HF potential matrix
        dm : 2D ndarray
            Density matrix, for DIIS
        cycle : int
            Then present SCF iteration step, for DIIS
        diis : an object of :attr:`SCF.DIIS` class
            DIIS object to hold intermediate Fock and error vectors
        diis_start_cycle : int
            The step to start DIIS.  Default is 0.
        level_shift_factor : float or int
            Level shift (in AU) for virtual space.  Default is 0.
    """
    # copied from hf get_fock, the only difference is that we update h1 in eacy iteration

    if mf.eta is None:
        mf.initialize_bare_fock(dm)
        mf.initialize_eta(dm)

    h1e = mf.get_hcore(dm=dm, dress=True)
    if vhf is None:
        vhf = mf.get_veff(mf.mol, dm)

    f = h1e + vhf
    if cycle > -1:
        mf.update_variational_params()

    if cycle < 0 and diis is None:  # Not inside the SCF iteration
        return f

    if diis_start_cycle is None:
        diis_start_cycle = mf.diis_start_cycle
    if level_shift_factor is None:
        level_shift_factor = mf.level_shift
    if damp_factor is None:
        damp_factor = mf.damp
    if s1e is None:
        s1e = mf.get_ovlp()
    if dm is None:
        dm = mf.make_rdm1()

    if 0 <= cycle < diis_start_cycle - 1 and abs(damp_factor) > 1e-4:
        f = damping(s1e, dm * 0.5, f, damp_factor)
    if diis is not None and cycle >= diis_start_cycle:
        #params = diis.update(s1e, dm, f, mf, h1e, vhf)
        variables, gradients = mf.pre_update_params()
        params = diis.update(s1e, dm, f, mf, h1e, vhf, var=variables, var_grad=gradients)
        f = mf.set_params(params, fock_shape=f.shape)
    if abs(level_shift_factor) > 1e-4:
        f = level_shift(s1e, dm * 0.5, f, level_shift_factor)
    return f


# may be better to implement QEDHF as a HF instance, need to run bare HF first and run QED-HF
# i.e., class HF(hf.SCF)


# inheritance from mqed_hf
from openms.mqed import qedhf
from openms.lib.boson import Photon
from openms.lib.boson import get_dipole_ao
from openms.lib.mathlib import full_cholesky_orth
import openms

class RHF(qedhf.RHF):
    # class HF(lib.StreamObject):
    r"""
    QEDSCF base class. Non-relativistic RHF.

    :param object mol: molecule object
    """

    def __init__(self, mol, xc=None, **kwargs):
        # print headers
        #logger.info(self, openms.__logo__)
        if openms._citations["scqedhf"] not in openms.runtime_refs:
            openms.runtime_refs.append(openms._citations["scqedhf"])

        qedhf.RHF.__init__(self, mol, **kwargs)

        self.eta = None
        self.eta_grad = None
        self.g_dipole = None
        self.precond = 0.1

        logger.debug(self,
            "\nTest: dot(mu_ao, mu_ao) = %f",
            lib.einsum("xuv,xuv->", self.qed.dipole_ao, self.qed.dipole_ao),
        )
        #
        self.qed.couplings_var = numpy.ones(self.qed.nmodes)
        self.qed.update_couplings()

        # save the original one-body integral to save time
        self.h1e_org = None  # original one-body integral
        # self.dip_ao = mol.intor("int1e_r", comp=3) # replaced with dipole_ao


        # check conditions of overlap and bilinear coupling matrix
        self._check_and_remove_linear_dep(threshold=1.e-7, lindep=1.e-7,
                                          cholesky_threshold=CHOLESKY_THRESHOLD,
                                          force_pivoted_cholesky=FORCE_PIVOTED_CHOLESKY)

        s1e = self.get_ovlp(mol)
        self.P, self.L = full_cholesky_orth(s1e, threshold=1.e-7)
        self.n_oao = self.P.shape[1]

        # removing linear dependency
        #self = remove_linear_dep(self)

        # will replace it with our general DIIS
        self.diis_space = 20
        self.DIIS = diis.SCF_DIIS
        #self.dump_flags()

    def initialize_bare_fock(self, dm = None):
        r"""
        return a bare fock matrix (non-qed) with initial guess dm
        """
        mol = self.mol
        if dm is None:
            dm = super(qedhf.RHF, self).get_init_guess(mol, self.init_guess)

        #h1e = super(qedhf.RHF, self).get_hcore(mol) # bare HF function
        #vhf = super(qedhf.RHF, self).get_veff(mol, dm)
        h1e = hf.get_hcore(mol) # bare HF function
        vhf = hf.get_veff(mol, dm)
        return h1e + vhf

    # get bare MO coefficients
    def get_bare_mo_coeff(self, dm):

        s1e = self.get_ovlp(self.mol)
        #h1e = hf.get_hcore(self.mol)
        #vhf = hf.get_veff(self.mol, dm)
        #fock = hf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        fock = self.initialize_bare_fock(dm)
        mo_energy, mo_coeff = self._eigh(fock, s1e)
        return mo_energy, mo_coeff

    def init_guess_by_1e(self, mol=None):
        if mol is None: mol = self.mol
        logger.info(self, '\nInitial guess from hcore in scqedhf.')
        h1e = self.get_hcore(mol)
        s1e = self.get_ovlp(mol)
        #mo_energy, mo_coeff = self.eig(h1e, s1e)
        mo_energy, mo_coeff =  cholesky_diag_fock_rao(self, h1e)
        mo_occ = self.get_occ(mo_energy, mo_coeff)
        return self.make_rdm1(mo_coeff, mo_occ)

    def _check_and_remove_linear_dep(self, threshold=LINEAR_DEP_THRESHOLD,
                       lindep=LINEAR_DEP_TRIGGER,
                       cholesky_threshold=CHOLESKY_THRESHOLD,
                       force_pivoted_cholesky=FORCE_PIVOTED_CHOLESKY):
        r"""

        """
        max_cond = 0.0
        S = self.get_ovlp()
        scond = numpy.linalg.cond(S)
        if scond > max_cond: max_cond = scond

        for mode in range(self.qed.nmodes):
            gcond = numpy.linalg.cond(self.qed.gmat[mode])
            if gcond > max_cond: max_cond = gcond

        # matrix for transforming ao to oao
        # oao = X^H * ao * x
        # X^H S X = I or S = X^{-H} X^{-1}
        self.X = addons.partial_cholesky_orth_(S, canthr=threshold, cholthr=cholesky_threshold)
        #Xinv = linalg.inv(self.X)
        #print("self.X.shape = ", self.X.shape)
        #print("S = Xinv^H Xinv?", numpy.allclose(S, lib.dot(Xinv.conj().T, Xinv)))

        if max_cond < 1./lindep and not force_pivoted_cholesky:
            logger.info(self, '\nUsing canonical orthogonalization with threshold {}'.format(threshold))
            self._eigh = addons._eigh_with_canonical_orth(threshold)
        else:
            logger.info(self, '\nUsing partial Cholesky orthogonalization '
                    '(doi:10.1063/1.5139948, doi:10.1103/PhysRevA.101.032504)')
            logger.info(self, 'Using threshold {} for pivoted Cholesky'.format(cholesky_threshold))
            logger.info(self, 'Using threshold {} to orthogonalize the subbasis'.format(threshold))
            self._eigh = addons._eigh_with_pivot_cholesky(threshold, cholesky_threshold)


    def ao2mo(self, A):
        r"""Transform AO into MO

        .. math::

            A_{MO} =& C^T_{MO} A_{AO} C_{MO} \\
            A_{pq} =& \sum_{uv} C^T_{pu} A_{uv} C_{vq} = \sum_{pq}
            C^*_{up} A_{uv} C_{vq}, \text{ and } C^T_{pu} = C_{up}

        """
        if self.mo_coeff is None:
            # mo_energy, self.mo_coeff = hf._init_guess_huckel_orbitals(self.mol)
            mo_energy, self.mo_coeff = self.get_bare_mo_coeff(dm)
        Amo = numpy.einsum("uv, vq->uq", A, self.mo_coeff)
        Amo = numpy.einsum("up, uq->pq", self.mo_coeff, Amo)

        return Amo

    def check_n_resolve_degeneracy(self, evals, mo2dipole, dm):
        nmo = mo2dipole.shape[0]
        ediff = 0
        threshold = 1.0e-8
        degeneracy = 1
        degeneracy2 = 1
        shift = 1.0e-3
        for p in range(nmo - 1):
            ediff = evals[p + 1] - evals[p]
            if abs(ediff) < threshold:
                degeneracy += 1
                degeneracy2 += 1
            elif abs(ediff) > threshold and degeneracy > 1:
                r = p + 1 - degeneracy
                s = p + 1

                # get fock in AO with original fock
                fock = self.initialize_bare_fock(dm=dm)  # numpy.zeros((nao, nao))

                # transform into mo
                fock = self.ao2mo(fock)

                # dipole matrix in AO
                r_ao = get_dipole_ao(self.mol, add_nuc_dipole=False)
                sum_dipole_ao = numpy.sum(r_ao, axis=0)
                sum_dipole_mo = self.ao2mo(sum_dipole_ao)

                # plus shift: f_pq += shift * r_pq
                fock += shift * sum_dipole_mo

                # transform into dipole basis
                fock = unitary_transform(mo2dipole, fock)
                deg_fock = fock[r : r + degeneracy, r : r  + degeneracy]

                del sum_dipole_ao, sum_dipole_mo, r_ao
                del fock

                # diagonalize deg_fock
                eig, evecs = linalg.eigh(deg_fock)

                # the basis of the degenerate space --> the new basis
                # new = vector * deg_fock
                vectors = mo2dipole[:, r : s]
                # print(f"deg_fock.shape= {deg_fock.shape} {s-r} {vectors.shape}")
                vectors = numpy.einsum("ik,kj->ij", vectors, evecs)
                mo2dipole[:, r : s] = vectors

                del vectors, deg_fock
                degeneracy = 1

    def get_dm_do(self, dm, U):
        r"""Transform DM from ao to dipole orbital
        """
        s1e = self.get_ovlp(self.mol)
        su = numpy.einsum("ik,kj->ij", s1e, U)
        dm_do = unitary_transform(su, dm)
        del s1e, su
        return dm_do

    def initialize_eta(self, dm):
        r"""Initialize the eta parameters and dipole basis sets
        Ref:
        """

        mo_energy, self.mo_coeff = self.get_bare_mo_coeff(dm)

        nao = self.mol.nao_nr()
        self.eta = numpy.zeros((self.qed.nmodes, nao))
        self.eta_grad = numpy.zeros((self.qed.nmodes, nao))

        # diagonalize the gmat in MO; then get ao2dipole basis transformaiton
        # gmo_tot = numpy.zeros((nao, nao))
        gmo = numpy.zeros_like(self.gmat)  # gmat*sqrt(w/2) in MO
        # print(f"gmo/gmo_toto shapes, {gmo_tot.shape} {gmo.shape}")

        self.ao2dipole = numpy.zeros_like(self.gmat)  # gmat*sqrt(w/2) in MO
        self.mo2dipole = numpy.zeros_like(self.gmat)  # gmat*sqrt(w/2) in MO
        for i in range(self.qed.nmodes):
            gmo[i] = self.gmat[i] * numpy.sqrt(self.qed.omega[i] / 2.0) * self.qed.couplings_var[i]


            gmo[i] = self.ao2mo(gmo[i])  # transform into MO
            # gmo_tot += gmo[i]

            # create dipole basis
            # evals, evecs = linalg.eigh(gmo_tot)
            evals, evecs = linalg.eigh(gmo[i])

            # check degeneracy
            self.check_n_resolve_degeneracy(evals, evecs, dm)
            self.mo2dipole[i] = evecs
            self.eta[i] = evals

            # Creating the basis change matrix from ao to dipole basis
            # i.e., ao2dipole basis transformaiton
            self.ao2dipole[i] = numpy.einsum("ui, ip-> up",
            self.mo_coeff, self.mo2dipole[i])

        # get eri in Dipole basis
        for imode in range(self.qed.nmodes):
            U = self.ao2dipole[imode]
            self.eri_DO = self.construct_eri_DO(U)

#   end of initialize_eta

    def get_eta_gradient(self, dm_do, g_DO, dm=None):
        r"""Compute the gradient of energy with respect to eta.
        Only works for one mode currently:

        .. math::

             \frac{E}{d\eta} = &  \\
                             = &

        """
        nao = self.mol.nao_nr()
        onebody_deta = numpy.zeros(nao)
        twobody_deta = numpy.zeros(nao)

        # 2 * D(p, p) * g(p)
        diagonal_dm_do = numpy.diagonal(dm_do, axis1=1, axis2=2)
        omega_values = self.qed.omega[:, numpy.newaxis]

        # The broadcasting will align the shapes for element-wise operations
        #onebody_deta -= 2.0 * numpy.sum(diagonal_dm_do * g_DO / omega_values, axis=0)

        for p in range(nao):
            for imode in range(self.qed.nmodes):
                onebody_deta[p] -= 2.0 * dm_do[imode, p,p] * g_DO[imode, p] / self.qed.omega[imode]

        for imode in range(self.qed.nmodes):
            fc_derivative = self.gaussian_derivative_vectorized(self.eta, 0)
            tmp1 = 2.0 * self.h1e_DO * dm_do[imode] * fc_derivative
            tmp2 = (2.0 * dm_do[imode].diagonal().reshape(-1, 1) * dm_do[imode].diagonal() \
                   - dm_do[imode] * dm_do[imode].T) \
                   * g_DO[imode].reshape(1, -1) / self.qed.omega[imode]
            onebody_deta += numpy.sum(tmp1 - tmp2, axis=1)
        del fc_derivative, tmp1, tmp2

        fc_derivative = self.gaussian_derivative_vectorized(self.eta, 0, onebody=False)
        fc_derivative *= (2.0 * self.eri_DO - self.eri_DO.transpose(0, 3, 2, 1))
        tmp = lib.einsum('pqrs, rs-> pq', fc_derivative, dm_do[0, :, :], optimize=True)
        twobody_deta = lib.einsum('pq, pq-> p', tmp, dm_do[0, :, :], optimize=True)
        del fc_derivative, tmp

        self.eta_grad[0] = onebody_deta + twobody_deta
        #return onebody_deta + twobody_deta

    # variable gradients, here we only have eta
    get_var_gradient = get_eta_gradient


    def construct_eri_DO(self, U):
        r"""
        Repulsion integral modifier according to dipole self-energy terms
        """
        if self._eri is None:
            self._eri = self.mol.intor("int2e", aosym="s1")

        eri = self._eri.copy()
        nao = self.mol.nao_nr()
        if eri.size == nao**4:
            eri = eri.reshape((nao,)*4)

        # transformation U(u, p) * U(v, q) * U(r, s) * U(t, w) * eri(p, q, r, s) -> eri(u, v, w, t)
        eri = numpy.einsum("pu, qv, rw, st, pqrs->uvwt", U, U, U, U, eri, optimize=True)

        return eri

    # may need to overwrite the fock matrix to define the photon-mediated one-electron
    # part.?
    # Alternatively, we can add the one-electron part in veff, and save
    # the copy, so in the energy calculation, we need to extract the one electron part from
    # the veff

    get_fock = get_fock

    def get_jk(self, mol=None, dm=None, hermi=1, with_j=True, with_k=True, omega=None):
        """get jk matrix in the presence of electron_photon coupling in the coherent state
        representation:

        I_{ijkl} = I^e_{ijkl} + g_{ij}g_{kl}
        where I^e is the pure electronci two-body integral.
        the latter term counts for the photon-mediated correlations

        J_{uv} = \sum_{ls} D_{ls}(uv|ls)
        K_{uv} = \sum_{ls} D_{ls}(us|lv)

        Hence, the photon-mediated part of JK is
        J^p_{uv} = \sum_{ls} D_{ls}(uv|ls) = sum_{ls} D_{ls} g_{uv} g_{ls}
        K^p_{uv} = \sum_{ls} D_{ls} g_{us} g_{lv}

        """
        # Note the incore version, which initializes an _eri array in memory.
        if mol is None:
            mol = self.mol
        if dm is None:
            dm = self.make_rdm1()
            dm = self.get_dm_do(dm, U)

        # add dressing factor to two-body integrals (todo)
        for imode in range(self.qed.nmodes):
            #U = self.ao2dipole[imode]
            factor = self.FC_factor(self.eta, imode, onebody=False)
            eri_tmp = self.eri_DO * factor
            vj, vk = hf.dot_eri_dm(eri_tmp, dm, hermi, with_j, with_k)
            del eri_tmp
        return vj, vk

        # now add contribution from electron-photon coupling residue
        for imode in range(self.qed.nmodes):
            scale_mu = numpy.einsum("ls, ls->", dm, self.gmat[imode])
            vj += scale_mu * self.gmat[imode]
            tmp = numpy.einsum("ls, us->ul", dm, self.gmat[imode])
            vk += numpy.einsum("ul, lv->uv", tmp, self.gmat[imode])

        return vj, vk

    def update_Xuv(self):
        r"""Update X operator

        .. math::

           X_{\mu\nu} = \exp\left[ -\frac{f_\alpha}{\sqrt{2\omega_\alpha}}d^\alpha(a^\dagger_\alpha - a_\alpha) \right]

        """

        print("Update dress operator for electron X_{\mu\nu}")
        factor = numpy.zeros_like(self.gmat)
        print(factor.shape)
        nmode, nao, nao = factor.shape

        # update the renormalization/FC factors (will be moved to FC_factor)
        for imode in range(nmode):
            for p in range(nao):
                for q in range(nao):
                    tmp = self.qed.couplings_var[imode] * (self.eta[imode, p] - self.eta[imode, q])
                    tmp = tmp * tmp / (4.0 * self.qed.omega[imode])
                    factor[imode, p, q] = numpy.exp(-tmp)

    def get_gaussian_factor(self, eta, i, j, k=None, l=None):
        tmp = eta[i] - eta[j]
        if k is not None:
            tmp += eta[k] - eta[l]
        #tmp *= self.qed.couplings_var[imode] # multipy variational transformation parameters
        gaussian_factor = numpy.exp(-0.5 * (tmp / self.qed.omega[0]) ** 2)
        return gaussian_factor

    def FC_factor(self, eta, imode, onebody=True):
        r"""Compute Franck-Condon (or renormalization) factor

        FIXME: check the whether eta has sqrt{\omega/2} or not

        .. math::

           \chi^\alpha_{pq} = \exp[-\frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})^2}{4\omega_\alpha}]

        """
        nao = self.gmat[imode].shape[0]
        if onebody:
            p, q = numpy.ogrid[:nao, :nao]
            diff_eta = eta[imode, p] - eta[imode, q]
            tmp = self.qed.couplings_var[imode]
        else:
            p, q, r, s = numpy.ogrid[:nao, :nao, :nao, :nao]
            diff_eta = eta[imode, p] - eta[imode, q] +  eta[imode, r] - eta[imode, s]
            tmp = 1.0

        tmp = 1.0
        if False: # depending on wether eta has sqrt(w/2) factors:
            tmp = tmp / numpy.sqrt(2.0 * self.qed.omega[imode])
        else:
            tmp = tmp / self.qed.omega[imode]
        factor = numpy.exp(-0.5 * (tmp * diff_eta) ** 2)
        if onebody:
            return factor.reshape(nao, nao)
        else:
            return factor.reshape(nao, nao, nao, nao)

    def gaussian_derivative_vectorized(self, eta, imode, onebody=True):
        nao = eta.shape[1]
        # Calculate diff_eta considering broadcasting
        if onebody:
            p, q = numpy.ogrid[:nao, :nao]
            diff_eta = eta[imode, q] - eta[imode, p]
        else:
            p, q, r, s = numpy.ogrid[:nao, :nao, :nao, :nao]
            diff_eta = eta[imode, q] - eta[imode, p] +  eta[imode, s] - eta[imode, r]

        tmp = 1.0 # self.qed.couplings_var[imode]
        if False:  # Adjust this condition as needed
            tmp /= numpy.sqrt(2.0 * self.qed.omega[imode])
        else:
            tmp /= self.qed.omega[imode]

        # Apply the derivative formula
        derivative = numpy.exp(-0.5 * (tmp * diff_eta) ** 2) * (tmp ** 2) * diff_eta
        if onebody:
            return derivative.reshape(nao, nao)
        else:
            return  derivative.reshape(nao, nao, nao, nao)


    def gaussian_derivative(self, eta, imode, p, q, r=None, s = None):
        r"""Compute Franck-Condon (or renormalization) derivative (/ d\eta)

        FIXME: check the whether eta has sqrt{\omega/2} or not

        .. math::

           \chi^\alpha_{pq} = \exp[-\frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})^2}{4\omega_\alpha}]
                            * - \frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})}{2\omega_\alpha}

        """
        #derivative = numpy.zeros_like(self.gmat[imode])
        #nao = derivative.shape[0]
        diff_eta = (eta[imode, q] - eta[imode, p])
        if r is not None:
            diff_eta += (eta[imode, s] - eta[imode, r])

        tmp = 1.0 # self.qed.couplings_var[imode]
        if False: # depending on wether eta has sqrt(w/2) factors:
            tmp = tmp / numpy.sqrt(2.0 * self.qed.omega[imode])
        else:
            tmp = tmp / self.qed.omega[imode]

        derivative = numpy.exp(-0.5*(tmp*diff_eta)**2) * tmp**2 * diff_eta
        return derivative

    def get_h1e_DO(self, mol=None, dm=None):
        r"""QED variational transformaiton dressed one-body integral.

        .. math::

            h_{uv} = h_{u'v'} \prod_\alpha U^\alpha_{up} U^\alpha_{vq}
                    \exp[-\chi^\alpha_{pq}] U^\alpha_{pu'}U^\alpha_{qv'}

        where

        .. math::

            \chi^\alpha_{pq} = -\frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})^2}{4\omega_\alpha}.

        """
        # considering moving the DSE correciton to this function
        if mol is None:
            mol = self.mol
        if self.h1e_org is None:
            self.h1e_org = hf.get_hcore(mol)
        h1e = self.h1e_org.copy()

        nmode, nao, nao = self.gmat.shape
        self.dm_do = numpy.zeros((nmode, nao, nao))
        if self.g_dipole is None:
            self.g_dipole = numpy.zeros((nmode,nao))

        # FIXME: generalized it to multiple modes
        for imode in range(self.qed.nmodes):

            U = self.ao2dipole[imode]
            self.h1e_DO = unitary_transform(U, h1e)
            gtmp = self.gmat[imode] * numpy.sqrt(self.qed.omega[imode] / 2.0)
            gtmp *= self.qed.couplings_var[imode]
            gtmp = unitary_transform(U, gtmp)

            # one-body operator h1e_pq = h1e_pq + g_pq(p, l) * g_pq(l, p)
            for p in range(nao):
                self.g_dipole[imode, p] = gtmp[p, p] - self.eta[imode, p]
                self.h1e_DO[p, p] += self.g_dipole[imode, p] ** 2 / self.qed.omega[imode]
            del gtmp

            # transform DM from AO to DO
            self.dm_do[imode] = self.get_dm_do(dm, U)

            # Tr[g_pq * D] in DO
            g_dot_D = numpy.diagonal(self.dm_do[imode, :, :]) @ self.g_dipole[imode, :]

    def get_hcore(self, mol=None, dm=None, dress=False):
        r"""QED variational transformaiton dressed one-body integral.

        .. math::

            h_{uv} = h_{u'v'} \prod_\alpha U^\alpha_{up} U^\alpha_{vq}
                    \exp[-\chi^\alpha_{pq}] U^\alpha_{pu'}U^\alpha_{qv'}

        where

        .. math::

            \chi^\alpha_{pq} = -\frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})^2}{4\omega_\alpha}.

        """
        # considering moving the DSE correciton to this function
        if mol is None:
            mol = self.mol
        if self.h1e_org is None:
            self.h1e_org = hf.get_hcore(mol)

        if not dress:
            h1e = self.h1e_org.copy()
        else:
            h1e_DO = self.h1e_DO.copy()
            nmode, nao, nao = self.gmat.shape
            for imode in range(self.qed.nmodes):
                # update the renormalization/FC factors
                # and dress h1e : h_pq  * G_{pq}
                factor = self.FC_factor(self.eta, imode)
                if imode == 0:
                    h1e = numpy.einsum("pq, pq->pq", h1e_DO, factor)
                else:
                    h1e = numpy.einsum("pq, pq->pq", h1e, factor)
            del h1e_DO

            U = self.ao2dipole[0]
            Uinv = linalg.inv(U)
            h1e = unitary_transform(Uinv, h1e)

        return h1e

    # get_veff = get_veff
    def get_veff(self, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1):
        r"""QED Hartree-Fock potential matrix for the given density matrix

        .. math::
            V_{eff} = J - K/2 + \bra{i}\lambda\cdot\mu\ket{j}

        """
        # we also need to update hcore as it's dressed by photon displacement

        if mol is None:
            mol = self.mol
        if dm is None:
            dm = self.make_rdm1()

        nao = self.mol.nao_nr()
        """
        DSE-mediated one-electron parts:

         2 * \title{g}_{pp} * sum_{q} [D_{qq} \title{g}_{qq}]
                                         mean_value
         -D_{qp}\tidle{g}_{pq} * \tilde{g}_{qq} (diagonal element is then g_pq(p)**2)
        """

        imode = 0
        U = self.ao2dipole[imode]
        dm_do = self.get_dm_do(dm, U)

        g_dot_D = numpy.diagonal(dm_do) @ self.g_dipole[imode, :]
        vhf_do = numpy.zeros((nao,nao))

        # vectorized code
        p_indices = numpy.arange(nao)
        vhf_do[p_indices, p_indices] += (2.0 * self.g_dipole[imode, p_indices] * g_dot_D -
                                         numpy.square(self.g_dipole[imode, p_indices]) * dm_do[p_indices, p_indices]) / self.qed.omega[0]

        vhf_do_offdiag = numpy.zeros_like(vhf_do)
        # Calculate off-diagonal elements
        p, q = numpy.triu_indices(nao, k=1)
        vhf_do_offdiag[p, q] -= self.g_dipole[imode, p] * self.g_dipole[imode, q] * dm_do[q, p] / self.qed.omega[0]
        vhf_do_offdiag[q, p] = vhf_do_offdiag[p, q]  # Exploit symmetry
        vhf_do += vhf_do_offdiag

        # vectorized code
        fc_factor = self.FC_factor(self.eta, imode, onebody=False)
        fc_factor *= (1.0 * self.eri_DO - 0.5 * self.eri_DO.transpose(0, 3, 2, 1))
        vhf = 0.5 * lib.einsum('pqrs, rs->pq', fc_factor, dm_do, optimize=True)
        vhf += 0.5 * lib.einsum('qprs, rs->pq', fc_factor, dm_do, optimize=True)
        vhf_do += vhf

        # transform back to AO
        Uinv = linalg.inv(U)
        vhf = unitary_transform(Uinv, vhf_do)

        return vhf

    def dump_flags(self, verbose=None):
        return hf.RHF.dump_flags(self, verbose)

    def get_var_norm(self):
        var_norm = linalg.norm(self.eta_grad)/numpy.sqrt(self.eta.size)
        return var_norm

    def update_variational_params(self):
        self.eta -= self.precond * self.eta_grad
        # self.eta -= 0.1 * self.eta_grad

    def pre_update_params(self):
        variables = self.eta
        gradients = self.eta_grad
        return variables, gradients

    def set_params(self, params, fock_shape=None):

        fsize = numpy.prod(fock_shape)
        f = params[:fsize].reshape(fock_shape)
        etasize = self.eta.size
        if params.size > fsize:
            self.eta = params[fsize:fsize+etasize].reshape(self.eta_grad.shape)
        return f

    kernel = kernel

    def post_kernel(self, envs):
        r"""
        Use the post kernel to print citation informations
        """
        breakline = '='*80
        logger.info(self, f"\n{breakline}")
        logger.info(self, f"*  Hoollary, the job is done!\n")
        logger.info(self, f"Citations:")
        for i, citation in enumerate(openms.runtime_refs):
            logger.info(self, f"[{i+1}]. {citation}")
        logger.info(self, f"{breakline}\n")

# end of scqedhf RHF class

class RKS(rks.KohnShamDFT, RHF):
    def __init__(self, mol, xc="LDA,VWN", **kwargs):
        RHF.__init__(self, mol, **kwargs)
        rks.KohnShamDFT.__init__(self, xc)

    def dump_flags(self, verbose=None):
        RHF.dump_flags(self, verbose)
        return rks.KohnShamDFT.dump_flags(self, verbose)

    get_veff = rks.get_veff
    get_vsap = rks.get_vsap
    energy_elec = rks.energy_elec


if __name__ == "__main__":
    # will add a loop
    import numpy
    from pyscf import gto, scf

    itest = -2
    zshift = itest * 2.5
    print(f"zshift={zshift}")

    atom = """H 0 0 0; F 0 0 1.75202"""
    atom = f"H          0.86681        0.60144        {5.00000+zshift};\
             F         -0.86681        0.60144        {5.00000+zshift};\
             O          0.00000       -0.07579        {5.00000+zshift};\
             He         0.00000        0.00000        {7.50000+zshift}"

    mol = gto.M(
        atom=atom,
        basis="sto3g",
        #basis="cc-pvdz",
        unit="Angstrom",
        symmetry=True,
        verbose=3,
    )
    print("mol coordinates=\n", mol.atom_coords())

    """
    hf = scf.HF(mol)
    hf.max_cycle = 200
    hf.conv_tol = 1.0e-8
    hf.diis_space = 10
    hf.polariton = True
    mf = hf.run(verbose=4)

    print("electronic energies=", mf.energy_elec())
    print("nuclear energy=     ", mf.energy_nuc())
    dm = mf.make_rdm1()
    """

    print(
        "\n=========== self-consistent SC-QED-HF calculation  ======================\n"
    )

    from openms.mqed import scqedhf as qedhf

    nmode = 1
    cavity_freq = numpy.zeros(nmode)
    cavity_mode = numpy.zeros((nmode, 3))
    cavity_freq[0] = 0.5
    cavity_mode[0, :] = 0.1 * numpy.asarray([1, 1, 1])
    cavity_mode[0, :] = 0.05 * numpy.asarray([0, 0, 1])  # * .1534237789543689328 #* 0.15163914700516712830
    cavity_mode[0, :] = 1.e-1 * numpy.asarray([0, 0, 1])  # * .1534237789543689328 #* 0.15163914700516712830

    mol.verbose = 4

    qedmf = qedhf.RHF(mol, xc=None, cavity_mode=cavity_mode, cavity_freq=cavity_freq, add_nuc_dipole=True)
    qedmf.max_cycle = 500
    qedmf.verbose = 5
    qedmf.init_guess ="hcore"
    qedmf.kernel() #dm0=dm)

    print(f"\n Etot is: {qedmf.e_tot}; ref = ")
