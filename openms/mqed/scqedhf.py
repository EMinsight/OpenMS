#
# @ 2023. Triad National Security, LLC. All rights reserved.
#
# This program was produced under U.S. Government contract 89233218CNA000001
# for Los Alamos National Laboratory (LANL), which is operated by Triad
# National Security, LLC for the U.S. Department of Energy/National Nuclear
# Security Administration. All rights in the program are reserved by Triad
# National Security, LLC, and the U.S. Department of Energy/National Nuclear
# Security Administration. The Government is granted for itself and others acting
# on its behalf a nonexclusive, paid-up, irrevocable worldwide license in this
# material to reproduce, prepare derivative works, distribute copies to the
# public, perform publicly and display publicly, and to permit others to do so.
#
# Authors:   Yu Zhang    <zhy@lanl.gov>
#          Ilia Mazin <imazin@lanl.gov>
#

import time
import numpy
from scipy import linalg

from pyscf import ao2mo
from pyscf import dft
from pyscf import lib
from pyscf import scf
from pyscf.lib import logger
#from pyscf.scf import diis

import openms
from openms.lib import boson
from openms.lib import scipy_helper
from openms.lib import mathlib
from openms.mqed import diis
from openms.mqed import qedhf
from openms import __config__

TIGHT_GRAD_CONV_TOL = getattr(__config__, "TIGHT_GRAD_CONV_TOL", True)
LINEAR_DEP_THRESHOLD = getattr(__config__, "LINEAR_DEP_THRESHOLD", 1e-8)
CHOLESKY_THRESHOLD = getattr(__config__, "CHOLESKY_THRESHOLD", 1e-10)
FORCE_PIVOTED_CHOLESKY = getattr(__config__, "FORCE_PIVOTED_CHOLESKY", False)
LINEAR_DEP_TRIGGER = getattr(__config__, "LINEAR_DEP_TRIGGER", 1e-10)


#def kernel(mf, conv_tol=1e-10, conv_tol_grad=None,
#           dump_chk=True, dm0=None, callback=None, conv_check=True, **kwargs):
#    r"""
#    SCF kernel: the main QED-HF driver.
#
#    Modified version of :external:func:`hf.kernel <pyscf.scf.hf.kernel>`
#    from PySCF. The main difference is:
#
#    - updating one-electron integrals with :meth:`~SCRHF.get_hcore` within
#      the SCF cycle, due to new DSE-mediated terms in the OEI which depend
#      on the electronic density matrix, ``dm``.
#
#    Parameters
#    ----------
#    mf : :class:`RHF <mqed.qedhf.RHF>`
#        Instance of OpenMS mean-field class.
#
#    Keyword Arguments
#    -----------------
#    conv_tol : float
#        Energy convergence threshold.
#        **Optional**, ``default = 1e-10``.
#    conv_tol_grad : float
#        Energy gradients convergence threshold.
#        **Optional**, ``default = sqrt(conv_tol)``.
#    dump_chk : bool
#        Whether to save SCF intermediate results
#        in the checkpoint file.
#        **Optional**, ``default = True``.
#    dm0 : :class:`~numpy.ndarray`
#        Initial guess density matrix. If not given (the default),
#        the kernel takes the density matrix generated by
#        :external:meth:`~pyscf.scf.hf.SCF.get_init_guess`.
#    callback : function(envs_dict) => None
#        callback function takes one ``dict`` as the argument which
#        is generated by built-in function :func:`locals`, so that
#        the callback function can access all local variables in the
#        current environment.
#    conv_check : bool
#        Whether to perform an additional SCF cycle after convergence
#        criteria are met. **Optional**, ``default = True``.
#
#    Return
#    ------
#    scf_conv : bool
#        Whether SCF has converged.
#    e_tot : float
#        QED Hartree-Fock energy of last iteration.
#    mo_energy : :class:`~numpy.ndarray`
#        Orbital energies. Depending on the ``eig`` function provided by
#        ``mf`` object, the orbital energies may **NOT** be sorted.
#    mo_coeff : :class:`~numpy.ndarray`
#        Orbital coefficients.
#    mo_occ : :class:`~numpy.ndarray`
#        Orbital occupancies. The occupancies may **NOT** be sorted from
#        large to small.
#    """
#
#    if 'init_dm' in kwargs:
#        err_msg = "You see this error message because of the API " + \
#                  "updates in pyscf v0.11. Keyword argument 'init_dm' " + \
#                  "is replaced by 'dm0'"
#        raise RuntimeError(err_msg)
#
#    cput0 = (logger.process_clock(), logger.perf_counter())
#
#    if conv_tol_grad is None:
#        conv_tol_grad = numpy.sqrt(conv_tol)
#        log_msg = f"Set gradient convergence threshold to {conv_tol_grad}"
#        logger.info(mf, log_msg)
#
#    mol = mf.mol
#    s1e = mf.get_ovlp(mol)
#
#    if dm0 is None:
#        dm = scf.hf.get_init_guess(mol, mf.init_guess)
#    else:
#        dm = dm0
#
#    # Initial (bare) electronic energy
#    h1e = mf.bare_h1e = scf.hf.get_hcore(mol)
#    vhf = scf.hf.get_veff(mol, dm)
#    e_tot = mf.energy_tot(dm, h1e, vhf)
#    logger.info(mf, 'init E (non-QED)= %.15g', e_tot)
#
#    # Update "z_alpha" values, if CS representation
#    mf.qed.update_cs(dm)
#
#    # Create initial photonic eigenvector guess for each mode
#    for a in range(mf.qed.nmodes):
#        mf.qed.boson_coeff[a] = mf.qed.update_boson_coeff(e_tot, dm, a)
#
#    # Initialize additional variational parameters,
#    # construct 'h1e' in dipole (DO) basis
#    # (used by SC-QED-HF/VT-QED-HF subclasses)
#    mf.init_var_params(dm)
#    mf.get_h1e_DO(dm)
#
#    # Transform density matrix initial guess like the
#    # init_guess_by_1e function? Then, type of guess
#    # shouldn't matter?
#
#    # Compute RAO basis
#    mo_energy, mo_coeff = cholesky_diag_fock_rao(mf, h1e+vhf)
#    mo_occ = mf.get_occ(mo_energy, mo_coeff)
#    dm = mf.make_rdm1(mo_coeff, mo_occ)
#
#    # Initial (RAO) electronic energy
#    h1e = mf.get_hcore(mol, dm)
#    vhf = mf.get_veff(mol, dm)
#    e_tot = mf.energy_tot(dm, h1e, vhf)
#    logger.info(mf, 'init E (RAO)= %.15g', e_tot)
#
#    scf_conv = False
#    mo_energy = mo_coeff = mo_occ = None
#
#    # Skip SCF iterations. Compute only the total energy of the initial density
#    if mf.max_cycle <= 0:
#        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
#        mo_energy, mo_coeff = mf.eig(fock, s1e)
#        mo_occ = mf.get_occ(mo_energy, mo_coeff)
#        return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ
#
#    # Setup DIIS parameters
#    if isinstance(mf.diis, lib.diis.DIIS):
#        mf_diis = mf.diis
#    elif mf.diis:
#        assert issubclass(mf.DIIS, lib.diis.DIIS)
#        mf_diis = mf.DIIS(mf, mf.diis_file)
#        mf_diis.space = mf.diis_space
#        mf_diis.rollback = mf.diis_space_rollback
#
#        # We get the used orthonormalized AO basis from any old eigendecomposition.
#        # Since the ingredients for the Fock matrix have already been built, we can
#        # just go ahead and use it to determine the orthonormal basis vectors.
#        fock = mf.get_fock(h1e, s1e, vhf, dm)
#        _, mf_diis.Corth = mf.eig(fock, s1e)
#    else:
#        mf_diis = None
#
#    if dump_chk and mf.chkfile:
#        # Explicit overwrite the mol object in chkfile
#        # Note in pbc.scf, mf.mol == mf.cell, cell is saved under key "mol"
#        scf.chkfile.save_mol(mol, mf.chkfile)
#
#    # A preprocessing hook before the SCF iteration(s)
#    mf.pre_kernel(locals())
#    mf.check_sanity()
#
#    cput1 = logger.timer(mf, 'initialize scf', *cput0)
#    for cycle in range(mf.max_cycle):
#        time0 = time.time()
#        dm_last = dm
#        last_hf_e = e_tot
#
#        # Update gradients of additional variational parameters
#        # and 'h1e' in DO basis (used by SC-QED-HF/VT-QED-HF subclasses)
#        # update h1e in DO
#        time1 = time.time()
#        mf.grad_var_params(mf.dm_do, mf.g_dipole, dm=dm)
#        time_etagrad = time.time() - time1
#
#        time1 = time.time()
#        mf.get_h1e_DO(dm)
#        time_h1e_do = time.time() - time1
#
#
#        # TO DO: Update photonic coefficients and energy
#        #
#        #
#        #
#        #
#        #
#
#        # Update h1e and Fock
#        time1 = time.time()
#        h1e = mf.get_hcore(mol, dm)
#        time_hcore = time.time() - time1
#
#        time1 = time.time()
#        fock = mf.get_fock(h1e, s1e, vhf, dm, cycle, mf_diis)
#        time_fock = time.time() - time1
#
#        # Diagonalize current Fock matix and update density matrix
#        mo_energy, mo_coeff = mf.eig(fock, s1e)
#        mo_occ = mf.get_occ(mo_energy, mo_coeff)
#        dm = mf.make_rdm1(mo_coeff, mo_occ)
#
#        # Update h1e, vhf, and e_tot
#        time1 = time.time()
#        h1e = mf.get_hcore(mol, dm)
#        time_hcore = time.time() - time1
#
#        time1 = time.time()
#        vhf = mf.get_veff(mol, dm, dm_last, vhf)
#        time_veff = time.time() - time1
#
#        e_tot = mf.energy_tot(dm, h1e, vhf)
#
#        # Here, Fock matrix is h1e + vhf, without DIIS. Calling get_fock
#        # instead of the statement "fock = h1e + vhf" because Fock matrix
#        # may be modified in some methods.
#        time1 = time.time()
#        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
#        time_fock += time.time() - time1
#
#        # Check SCF convergence
#        norm_eta = mf.norm_var_params()
#        norm_gorb = linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))
#        norm_gorb = norm_gorb + norm_eta
#        if not TIGHT_GRAD_CONV_TOL:
#            norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)
#        norm_ddm = linalg.norm(dm-dm_last)
#        logger.info(mf, '\ncycle= %d E= %.15g  delta_E= %4.3g  |g|= %4.3g  |g_var|= %4.3g  |ddm|= %4.3g',
#                    cycle+1, e_tot, e_tot-last_hf_e, norm_gorb, norm_eta, norm_ddm)
#        logger.debug(mf, "cycle= %d times: h1e_do = %.6g eta_grad = %.6g hcore = %.6g veff = %.6g  fock = %.6g scf = %.6g",
#                    cycle+1, time_h1e_do, time_etagrad, time_hcore, time_veff, time_fock, time.time()-time0)
#
#        if callable(mf.check_convergence):
#            scf_conv = mf.check_convergence(locals())
#        elif abs(e_tot-last_hf_e) < conv_tol and norm_gorb < conv_tol_grad:
#            scf_conv = True
#
#        if dump_chk:
#            mf.dump_chk(locals())
#
#        if callable(callback):
#            callback(locals())
#
#        cput1 = logger.timer(mf, 'cycle= %d'%(cycle+1), *cput1)
#
#        if scf_conv:
#            break
#
#    if scf_conv and conv_check:
#        # An extra diagonalization, to remove level shift
#        mo_energy, mo_coeff = mf.eig(fock, s1e)
#        mo_occ = mf.get_occ(mo_energy, mo_coeff)
#        dm, dm_last = mf.make_rdm1(mo_coeff, mo_occ), dm
#
#        # TO DO: Extra update of photonic coefficients and energy
#        #
#        #
#        #
#        #
#        #
#
#        # Final update of h1e, vhf, e_tot, fock
#        h1e = mf.get_hcore(mol, dm)
#        vhf = mf.get_veff(mol, dm, dm_last, vhf)
#        e_tot, last_hf_e = mf.energy_tot(dm, h1e, vhf), e_tot
#        fock = mf.get_fock(h1e, s1e, vhf, dm)
#
#        # Verify SCF convergence
#        norm_eta = mf.norm_var_params()
#        norm_gorb = linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))
#        norm_gorb = norm_gorb + norm_eta
#        if not TIGHT_GRAD_CONV_TOL:
#            norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)
#        norm_ddm = linalg.norm(dm-dm_last)
#
#        conv_tol = conv_tol * 10
#        conv_tol_grad = conv_tol_grad * 3
#        if callable(mf.check_convergence):
#            scf_conv = mf.check_convergence(locals())
#        elif abs(e_tot-last_hf_e) < conv_tol or norm_gorb < conv_tol_grad:
#            scf_conv = True
#        logger.info(mf, 'Extra cycle  E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',
#                    e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)
#        if dump_chk:
#            mf.dump_chk(locals())
#
#    logger.timer(mf, 'scf_cycle', *cput0)
#    # A post-processing hook before return
#    mf.post_kernel()
#    return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ
#
#
#def get_orbitals_from_rao(C, P):
#    r"""Transform
#    Sets the orbital coefficients from the orbital coefficients in RAO
#       orbital_coefficients = P C
#    """
#    return lib.einsum("ik, kj->ij", P, C)
#
#
#def cholesky_diag_fock_rao(mf, h1e):
#    r"""
#    Diagonalize the Fock matrix in RAO basis
#    """
#    # Transform from AO to RAO basis
#    F_rao = mathlib.unitary_transform(h1e, mf.P)
#    S_rao = get_reduced_overlap(mf.L)
#    mo_energy, mo_coeff = mf.eig(F_rao, S_rao)
#    mo_coeff = get_orbitals_from_rao(mo_coeff, mf.P)
#
#    return mo_energy, mo_coeff
#
#
#def get_reduced_overlap(L):
#    r"""Compute reduced overlap matrix, :math:`S_{rao} = L L^T`."""
#    return lib.einsum("ik, kj->ij", L, L.conj().T)
#
#
#class SCRHF(qedhf.RHF):
#    r"""Non-relativistic SC-QED-RHF subclass."""
#    def __init__(
#        self, mol, qed=None, xc=None, **kwargs):
#
#        super().__init__(mol, qed, xc, **kwargs)
#
#        if "scqedhf" not in openms.runtime_refs:
#            openms.runtime_refs.append("scqedhf")
#
#        self.eta = numpy.zeros((self.qed.nmodes, self.nao))
#        self.eta_grad = numpy.zeros((self.qed.nmodes, self.nao))
#
#        self.mo2dipole = numpy.zeros_like(self.qed.gmat)
#        self.ao2dipole = numpy.zeros_like(self.qed.gmat)
#
#        self.bare_fock_ao = numpy.zeros((self.nao, self.nao))
#        self.bf_mo_coeff = numpy.zeros((self.nao, self.nao))
#
#        self.g_dipole = None
#        self.precond = 0.1
#
#        # Parameters for dipole moment basis set degeneracy
#        self.dipole_degen_e_thresh = 1.0e-8
#        self.dipole_fock_shift = 1.0e-3
#
#        #dip_ao2 = lib.einsum("Xuv,Xuv->", self.qed.dipole_ao, self.qed.dipole_ao)
#        #log_msg = f"Test: dot(mu_ao, mu_ao) = {dip_ao2}"
#        #logger.debug(self, log_msg)
#
#        s1e = self.get_ovlp(mol)
#        # matrix for transforming ao to oao
#        # oao = X^H * ao * x
#        # X^H S X = I or S = X^{-H} X^{-1}
#        self.X = scipy_helper.partial_cholesky_orth(s1e, canthr=1.0e-7,
#                                                    cholthr=CHOLESKY_THRESHOLD)
#        #Xinv = linalg.inv(self.X)
#        #print("self.X.shape = ", self.X.shape)
#        #print("S = Xinv^H Xinv?", numpy.allclose(S, lib.dot(Xinv.conj().T, Xinv)))
#
#        # Check condition of overlap and e-p interaction matrices
#        scipy_helper.remove_linear_dep(self, threshold=1.0e-7, lindep=1.0e-7,
#                                       cholesky_threshold=CHOLESKY_THRESHOLD,
#                                       force_pivoted_cholesky=FORCE_PIVOTED_CHOLESKY)
#
#        self.L, self.P = mathlib.full_cholesky_orth(s1e, threshold=1.e-7)
#        self.n_oao = self.P.shape[1]
#
#        # will replace it with our general DIIS
#        self.diis_space = 20
#        self.DIIS = diis.SCF_DIIS
#
#
#    def get_hcore(self, mol=None, dm=None):
#        r"""Return one-body integrals dressed by photon field.
#
#        .. math::
#
#            h_{uv} = h_{u'v'} \prod_\alpha U^\alpha_{up} U^\alpha_{vq}
#                    \tt{exp}[-\chi^\alpha_{pq}] U^\alpha_{pu'}U^\alpha_{qv'}
#
#        where
#
#        .. math::
#
#            \chi^\alpha_{pq} = -\frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})^2}{4\omega_\alpha}.
#
#            QED variational transformation dressed one-body integral.
#
#        .. math::
#
#            h_{uv} = h_{u'v'} \prod_\alpha U^\alpha_{up} U^\alpha_{vq}
#                    \tt{exp}[-\chi^\alpha_{pq}] U^\alpha_{pu'}U^\alpha_{qv'}
#
#        where:
#
#        .. math::
#
#            \chi^\alpha_{pq} =
#            -\frac{f^2_\alpha (\eta_{\alpha, p} - \eta_{\alpha, q})^2}
#                  {4\omega_\alpha}
#        """
#
#        if mol is None: mol = self.mol
#        if dm is None: dm = self.make_rdm1()
#
#        sc_h1e = numpy.zeros((self.nao, self.nao))
#
#        for a in range(self.qed.nmodes):
#
#            ## Term 1
#            # Bare OEI in dipole basis
#            h1e_dipole = mathlib.unitary_transform(self.ao2dipole[a],
#                                                   self.bare_h1e)
#            # Gaussian factor
#            g_factor = self.get_gaussian_factor(a, one_body=True)
#            h1e = h1e_dipole * g_factor
#            del h1e_dipole
#
#            ## Term 2
#            # Bilinear interaction matrix, AO to dipole basis
#            g_dipole = self.qed.get_geb_ao(a)
#            g_dipole *= self.qed.couplings_var[a]
#            g_dipole = mathlib.unitary_transform(self.ao2dipole[a],
#                                                 g_dipole)
#
#            # Shift diagonal elements of bilinear interaction matrix
#            g_dipole -= numpy.diag(self.eta[a])
#
#            # Construct term 2 OEI contribution
#            term2 = numpy.diag((g_dipole ** 2) / self.qed.omega[a])
#            h1e += numpy.diag(term2)
#
#            ## Term 3
#
#
#            ## Term 4
#
#
#            # Transform h1e, dipole to AO basis
#            dipole2ao = linalg.inv(self.ao2dipole[a])
#            h1e = mathlib.unitary_transform(dipole2ao, h1e)
#
#            sc_h1e += h1e
#        return sc_h1e
#
#
#    '''
#    # may need to overwrite the fock matrix to define the photon-mediated one-electron
#    # part.?
#    # Alternatively, we can add the one-electron part in veff, and save
#    # the copy, so in the energy calculation, we need to extract the one electron part from
#    # the veff
#    def get_jk(self, mol=None, dm=None, hermi=1, with_j=True, with_k=True, omega=None):
#        r"""get jk matrix in the presence of electron_photon coupling in the coherent state
#        representation:
#
#        .. math::
#            I_{ijkl} = I^{bare}_{ijkl} + \sum_\alpha g^\alpha_{ij} g^\alpha_{kl}
#
#        where :math:`\mathbf{I}^{bare}` is the non-QED electronic two-body integral.
#        The second term accounts for the photon-mediated correlation. The non-QED
#        Coulomb (J) and Exchange (K) matrices are:
#
#        .. math::
#            J_{uv} &= \sum_{ls} D_{ls}(uv|ls) \\
#            K_{uv} &= \sum_{ls} D_{ls}(us|lv)
#
#        The photon-mediated correlation is included in J/K matrices by:
#
#        .. math::
#            J^p_{uv} &= \sum_{ls} D_{ls} \sum_\alpha (uv|ls)^\alpha
#                      = \sum_{ls} D_{ls} \sum_\alpha g^\alpha_{uv} g^\alpha_{ls} \\
#            K^p_{uv} &= \sum_{ls} D_{ls} \sum_\alpha (us|lv)^\alpha
#                      = \sum_{ls} D_{ls} \sum_\alpha g^\alpha_{us} g^\alpha_{lv}
#        """
#
#        # Note the incore version, which initializes an _eri array in memory.
#        if mol is None:
#            mol = self.mol
#        if dm is None:
#            U = self.ao2dipole[0]
#            dm = self.make_rdm1()
#            dm = self.get_dm_do(dm, U)
#
#        # add dressing factor to two-body integrals (todo)
#        for imode in range(self.qed.nmodes):
#            #U = self.ao2dipole[imode]
#            factor = self.FC_factor(self.eta, imode, onebody=False)
#            eri_tmp = self.eri_DO * factor
#            vj, vk = scf.hf.dot_eri_dm(eri_tmp, dm, hermi, with_j, with_k)
#            del eri_tmp
#        return vj, vk
#
#        # now add contribution from electron-photon coupling residue
#        for imode in range(self.qed.nmodes):
#            scale_mu = numpy.einsum("ls, ls->", dm, self.qed.gmat[imode])
#            vj += scale_mu * self.qed.gmat[imode]
#            tmp = numpy.einsum("ls, us->ul", dm, self.qed.gmat[imode])
#            vk += numpy.einsum("ul, lv->uv", tmp, self.qed.gmat[imode])
#
#        return vj, vk
#
#
#    def get_veff(self, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1):
#        r"""QED Hartree-Fock potential matrix for the given density matrix
#
#        .. math::
#            V_{eff} = J - K/2 + \bra{i}\lambda\cdot\mu\ket{j}
#
#        """
#        # we also need to update hcore as it's dressed by photon displacement
#
#        if mol is None:
#            mol = self.mol
#        if dm is None:
#            dm = self.make_rdm1()
#
#        nao = self.mol.nao_nr()
#        """
#        DSE-mediated one-electron parts:
#
#         2 * \title{g}_{pp} * sum_{q} [D_{qq} \title{g}_{qq}]
#                                         mean_value
#         -D_{qp}\tidle{g}_{pq} * \tilde{g}_{qq} (diagonal element is then g_pq(p)**2)
#        """
#
#        imode = 0
#        U = self.ao2dipole[imode]
#        dm_do = self.get_dm_do(dm, U)
#
#        g_dot_D = numpy.diagonal(dm_do) @ self.g_dipole[imode, :]
#        vhf_do = numpy.zeros((nao,nao))
#
#        # vectorized code
#        p_indices = numpy.arange(nao)
#        vhf_do[p_indices, p_indices] += (2.0 * self.g_dipole[imode, p_indices] * g_dot_D -
#                                         numpy.square(self.g_dipole[imode, p_indices]) * dm_do[p_indices, p_indices]) / self.qed.omega[0]
#
#        vhf_do_offdiag = numpy.zeros_like(vhf_do)
#        # Calculate off-diagonal elements
#        p, q = numpy.triu_indices(nao, k=1)
#        vhf_do_offdiag[p, q] -= self.g_dipole[imode, p] * self.g_dipole[imode, q] * dm_do[q, p] / self.qed.omega[0]
#        vhf_do_offdiag[q, p] = vhf_do_offdiag[p, q]  # Exploit symmetry
#        vhf_do += vhf_do_offdiag
#
#        # vectorized code
#        fc_factor = self.FC_factor(self.eta, imode, onebody=False)
#        fc_factor *= (1.0 * self.eri_DO - 0.5 * self.eri_DO.transpose(0, 3, 2, 1))
#        vhf = 0.5 * lib.einsum('pqrs, rs->pq', fc_factor, dm_do, optimize=True)
#        vhf += 0.5 * lib.einsum('qprs, rs->pq', fc_factor, dm_do, optimize=True)
#        vhf_do += vhf
#
#        # transform back to AO
#        Uinv = linalg.inv(U)
#        vhf = mathlib.unitary_transform(Uinv, vhf_do)
#
#        return vhf
#    '''
#
#
#    def get_gaussian_factor(self, mode, one_body=True):
#
#        # Number of states for photon mode
#        nb_mode = self.qed.nboson[mode]
#
#        # Construct < n | b - b\dagger | m >
#        h_od = numpy.diag(numpy.sqrt(numpy.arange(1, nb_mode)), k = -1) \
#               - numpy.diag(numpy.sqrt(numpy.arange(1, nb_mode)), k = 1)
#
#        b_evals = linalg.eigh(h_od)[1]
#        b_evals = numpy.sum((b_evals.conj() * b_evals).reshape(-1))
#
#        # Construct Gaussian factor
#        eta = self.eta[mode]
#
#        if one_body:
#            g_factor = eta[:, numpy.newaxis] - eta[numpy.newaxis, :]
#        else:
#            g_factor = eta[:, numpy.newaxis, numpy.newaxis, numpy.newaxis] \
#                     - eta[numpy.newaxis, :, numpy.newaxis, numpy.newaxis] \
#                     + eta[numpy.newaxis, numpy.newaxis, :, numpy.newaxis] \
#                     - eta[numpy.newaxis, numpy.newaxis, numpy.newaxis, :]
#
#        g_factor *= (b_evals / self.qed.omega[mode])
#        g_factor = numpy.exp(-0.5 * (g_factor ** 2))
#
#        return g_factor
#
#
#    def init_guess_by_1e(self, mol=None):
#        if mol is None: mol = self.mol
#
#        h1e = super(scf.hf.RHF, self).get_hcore(self.mol)
#        logger.info(self, '\nInitial guess from hcore in scqedhf.')
#
#        mo_energy, mo_coeff = cholesky_diag_fock_rao(self, h1e)
#        mo_occ = self.get_occ(mo_energy, mo_coeff)
#        return self.make_rdm1(mo_coeff, mo_occ)
#
#
#    def check_dipole_degeneracy(self, r_evals, r_evecs):
#        r"""Check and resolve degeneracies in the dipole moment basis.
#
#        Check provided dipole moment basis eigenvalues for degeneracy.
#        If the differences between the provided eigenvalues are all
#        :math:`>` :attr:`dipole_degen_e_thresh`, return un-modified
#        eigenvalues and eigenvectors.
#
#        Else, stored bare Fock matrix (:meth:`get_bare_fock`) is
#        transformed to MO basis. In MO basis, shift Fock matrix using
#        dipole moment matrix, also transformed to the MO basis, summed
#        over :math:`{\bm{x},\bm{y},\bm{z}}` Cartesian coordinates and
#        scaled by :attr:`dipole_fock_shift` value. Shifted Fock matrix
#        is transformed from MO to dipole basis, shifted eigenvectors of
#        degenerate eigenvalues are sliced and used to update the original
#        eigenvectors (those corresponding to the degenerate eigenvalues).
#
#        ..note::
#            By default, the :attr:`dipole_degen_e_thresh` and
#            :attr:`dipole_fock_shift` values are defined as :math:`1.0e-8`
#            and :math:`1.0e-3`, respectively. These values can be modified
#            by the user, if necessary.
#
#        Parameters
#        ----------
#        r_evals : :class:`~numpy.ndarray`
#            Eigenvalues of the dipole moment matrix,
#            (photon mode-dependent).
#        r_evecs : :class:`~numpy.ndarray`
#            Eigenvectors of the dipole moment matrix,
#            (photon mode-dependent).
#        dm : :class:`~numpy.ndarray`
#            Density matrix.
#
#        Return
#        ------
#        evals : :class:`~numpy.ndarray`
#            (Potentially-modified) eigenvalues of the
#            dipole moment matrix.
#        evecs : :class:`~numpy.ndarray`
#            (Potentially-modified) eigenvectors of the
#            dipole moment matrix.
#        """
#
#        # Parameters from mean-field object.
#        thresh = self.dipole_degen_e_thresh
#        fock_shift = self.dipole_fock_shift
#
#        # Work with copies of input arrays
#        evals = r_evals.copy()
#        evecs = r_evecs.copy()
#
#        # Energy indices that meet degeneracy threshold value
#        e_diffs = abs(evals[1:] - evals[:-1])
#        idx = numpy.where(e_diffs < thresh)[0]
#        degen_idx = numpy.unique(numpy.hstack((idx, idx+1)))
#
#        # Resolve degeneracy, if it exists
#        if degen_idx.size > 0:
#            # Fock matrix (non-QED), transformed to MO basis
#            fock = lib.einsum("up, uv, vq-> pq",
#                                self.bf_mo_coeff,
#                                self.bare_fock_ao,
#                                self.bf_mo_coeff)
#
#            # Dipole moment matrix, transformed to MO basis
#            sum_dipole_mo = lib.einsum("up, uv, vq-> pq",
#                                        self.bf_mo_coeff,
#                                        numpy.sum(self.qed.dipole_ao, axis=0),
#                                        self.bf_mo_coeff)
#
#            # Shift Fock matrix values
#            fock += (fock_shift * sum_dipole_mo)
#            del sum_dipole_mo
#
#            # Transform Fock matrix to dipole basis, slice degenerate indices
#            fock = mathlib.unitary_transform(evecs, fock)
#            dfock_idx = numpy.ix_(degen_idx, degen_idx)
#            deg_fock = fock[dfock_idx].copy()
#            del fock, dfock_idx
#
#            # Obtain shifted eigenvectors
#            new_evecs = linalg.eigh(deg_fock)[1]
#            del deg_fock
#
#            # Update degenerate eigenvectors
#            revecs_idx = numpy.ix_(numpy.arange(evecs.shape[0]), degen_idx)
#            r_evecs_slice = evecs[revecs_idx].copy()
#            r_evecs_slice = lib.einsum("ik, kj-> ij", r_evecs_slice, new_evecs)
#            evecs[revecs_idx] = r_evecs_slice.copy()
#            del r_evecs_slice, revecs_idx, degen_idx
#        return evals, evecs
#
#
#    def get_dm_do(self, dm, U):
#        r"""Transform density matrix from AO to dipole basis."""
#        s1e = self.get_ovlp(self.mol)
#        su = numpy.einsum("ik,kj->ij", s1e, U)
#        dm_do = mathlib.unitary_transform(su, dm)
#        del s1e, su
#        return dm_do
#
#
#    def get_bare_fock_ao(self, dm):
#        r"""Construct non-QED Fock matrix."""
#        h1e = super(scf.hf.RHF, self).get_hcore(self.mol)
#        vhf = super(scf.hf.RHF, self).get_veff(self.mol, dm)
#        return (h1e + vhf)
#
#
#    def initialize_eta(self, dm):
#        r"""Initialize the eta parameters and dipole basis set."""
#        s1e = self.get_ovlp(self.mol)
#        self.bare_fock_ao = self.get_bare_fock_ao(dm)
#        self.bf_mo_coeff = self.eig(self.bare_fock_ao, s1e)[1]
#
#        # Calculate eta and transformation matrices
#        for a in range(self.qed.nmodes):
#            # TODO: Rename back to MO after done testing, no need to delete
#            gmat_ao = self.qed.get_geb_ao(a)
#            gmat_ao *= self.qed.couplings_var[a]
#
#            # Transform from AO to MO basis and diagonalize
#            gmat_mo = mathlib.unitary_transform(self.bf_mo_coeff, gmat_ao)
#            del gmat_ao
#            evals, evecs = linalg.eigh(gmat_mo)
#
#            # Check and resolve degeneracies before saving eta values
#            # and "MO to dipole basis" transformation matrix
#            self.eta[a], self.mo2dipole[a] = self.check_dipole_degeneracy(evals, evecs)
#            del evals, evecs
#
#            # Create "AO to dipole basis" transformation matrix
#            self.ao2dipole[a] = lib.einsum("ma, md-> ad",
#                                           self.bf_mo_coeff, self.mo2dipole[a])
#
#            # Transform ERIs from AO to dipole basis
#            self.eri_DO = self.construct_eri_DO(self.ao2dipole[a])
#
#
#    def get_eta_gradient(self, dm_do, g_DO, dm=None):
#        r"""Compute the gradient of energy with respect to eta.
#        Only works for one mode currently:
#
#        .. math::
#
#             \frac{E}{d\eta} = &  \\
#                             = &
#
#        """
#        nao = self.mol.nao_nr()
#        onebody_deta = numpy.zeros(nao)
#        twobody_deta = numpy.zeros(nao)
#
#        # 2 * D(p, p) * g(p)
#        diagonal_dm_do = numpy.diagonal(dm_do, axis1=1, axis2=2)
#        omega_values = self.qed.omega[:, numpy.newaxis]
#
#        # The broadcasting will align the shapes for element-wise operations
#        #onebody_deta -= 2.0 * numpy.sum(diagonal_dm_do * g_DO / omega_values, axis=0)
#
#        for p in range(nao):
#            for a in range(self.qed.nmodes):
#                onebody_deta[p] -= 2.0 * dm_do[a, p,p] * g_DO[a, p] / self.qed.omega[a]
#
#        for a in range(self.qed.nmodes):
#            fc_derivative = self.gaussian_derivative_vectorized(self.eta, 0)
#            tmp1 = 2.0 * self.h1e_DO * dm_do[a] * fc_derivative
#            tmp2 = (2.0 * dm_do[a].diagonal().reshape(-1, 1) * dm_do[a].diagonal() \
#                   - dm_do[a] * dm_do[a].T) \
#                   * g_DO[a].reshape(1, -1) / self.qed.omega[a]
#            onebody_deta += numpy.sum(tmp1 - tmp2, axis=1)
#        del fc_derivative, tmp1, tmp2
#
#        fc_derivative = self.gaussian_derivative_vectorized(self.eta, 0, onebody=False)
#        fc_derivative *= (2.0 * self.eri_DO - self.eri_DO.transpose(0, 3, 2, 1))
#        tmp = lib.einsum('pqrs, rs-> pq', fc_derivative, dm_do[0, :, :], optimize=True)
#        twobody_deta = lib.einsum('pq, pq-> p', tmp, dm_do[0, :, :], optimize=True)
#        del fc_derivative, tmp
#
#        self.eta_grad[0] = onebody_deta + twobody_deta
#        #return onebody_deta + twobody_deta
#
#
#    def construct_eri_DO(self, U):
#        r"""Transform ERIs to dipole basis."""
#        if self._eri is None:
#            self._eri = self.mol.intor("int2e", aosym="s1")
#
#        eri = self._eri.copy()
#        if eri.shape != (self.nao, self.nao, self.nao, self.nao):
#            eri = ao2mo.restore(1, eri, self.nao)
#
#        eri = lib.einsum("pu, qv, rw, st, pqrs-> uvwt", U, U, U, U, eri)
#        return eri
#
#
#    def update_Xuv(self):
#        r"""Update :math:`X` operator.
#
#        .. math::
#            X_{\mu\nu} &= \tt{exp}
#                          \left[ - \sum_\al \frac{f_\alpha}{\sqrt{2\om_\al}}
#                          \bm{e}_\al \sum_{\mu\nu} \rho_{\mu\nu}
#                          \cdot \mel*{\mu}{\hat{D}}{\nu}
#                          \right] \sum_{nm} \mel*{n}{\cb{\al} - \ab{\al}}{m} \\
#                       &= \tt{exp}
#                          \left[ - \sum_\al \frac{f_\alpha}{\sqrt{2\om_\al}}
#                          \bm{e}_\al \sum_{\mu\nu} \rho_{\mu\nu}
#                          \cdot \mel*{\mu}{\hat{D}}{\nu}
#                          \right] \sum_{nm} C_{\al}^{n} C_{\al}^{m} \d{n}{m}
#        """
#
#        print("Update dress operator for electron X_{\mu\nu}")
#        factor = numpy.zeros_like(self.qed.gmat)
#        print(factor.shape)
#        nmode, nao, nao = factor.shape
#
#        # update the renormalization/FC factors (will be moved to FC_factor)
#        for a in range(nmode):
#            for p in range(nao):
#                for q in range(nao):
#                    tmp = self.qed.couplings_var[a] * (self.eta[a, p] - self.eta[a, q])
#                    tmp = tmp * tmp / (4.0 * self.qed.omega[a])
#                    factor[a, p, q] = numpy.exp(-tmp)
#
#
#    def get_gaussian_factor(self, mode, one_body=True):
#
#        eta = self.eta[mode]
#
#        if one_body:
#            g_factor = eta[:, numpy.newaxis] - eta[numpy.newaxis, :]
#        else:
#            g_factor = eta[:, numpy.newaxis, numpy.newaxis, numpy.newaxis] \
#                     - eta[numpy.newaxis, :, numpy.newaxis, numpy.newaxis] \
#                     + eta[numpy.newaxis, numpy.newaxis, :, numpy.newaxis] \
#                     - eta[numpy.newaxis, numpy.newaxis, numpy.newaxis, :]
#
#        g_factor /= self.qed.omega[mode]
#        g_factor = numpy.exp(-0.5 * (g_factor ** 2))
#
#        return g_factor
#
#
#    def FC_factor(self, eta, imode, onebody=True):
#        r"""Compute Franck-Condon (or renormalization) factor
#
#        FIXME: check the whether eta has sqrt{\omega/2} or not
#
#        .. math::
#
#           \chi^\al_{pq} = \tt{exp}[-\frac{f^2_\al(\eta_{\al,p} - \eta_{\al,q})^2}{4\om_\al}]
#        """
#        nao = self.qed.gmat[imode].shape[0]
#        if onebody:
#            p, q = numpy.ogrid[:nao, :nao]
#            diff_eta = eta[imode, p] - eta[imode, q]
#            tmp = self.qed.couplings_var[imode]
#        else:
#            p, q, r, s = numpy.ogrid[:nao, :nao, :nao, :nao]
#            diff_eta = eta[imode, p] - eta[imode, q] +  eta[imode, r] - eta[imode, s]
#            tmp = 1.0
#
#        tmp = 1.0
#        if False: # depending on wether eta has sqrt(w/2) factors:
#            tmp = tmp / numpy.sqrt(2.0 * self.qed.omega[imode])
#        else:
#            tmp = tmp / self.qed.omega[imode]
#        factor = numpy.exp(-0.5 * (tmp * diff_eta) ** 2)
#        if onebody:
#            return factor.reshape(nao, nao)
#        else:
#            return factor.reshape(nao, nao, nao, nao)
#
#
#    def gaussian_derivative_vectorized(self, eta, imode, onebody=True):
#        nao = eta.shape[1]
#        # Calculate diff_eta considering broadcasting
#        if onebody:
#            p, q = numpy.ogrid[:nao, :nao]
#            diff_eta = eta[imode, q] - eta[imode, p]
#        else:
#            p, q, r, s = numpy.ogrid[:nao, :nao, :nao, :nao]
#            diff_eta = eta[imode, q] - eta[imode, p] +  eta[imode, s] - eta[imode, r]
#
#        tmp = 1.0 # self.qed.couplings_var[imode]
#        if False:  # Adjust this condition as needed
#            tmp /= numpy.sqrt(2.0 * self.qed.omega[imode])
#        else:
#            tmp /= self.qed.omega[imode]
#
#        # Apply the derivative formula
#        derivative = numpy.exp(-0.5 * (tmp * diff_eta) ** 2) * (tmp ** 2) * diff_eta
#        if onebody:
#            return derivative.reshape(nao, nao)
#        else:
#            return  derivative.reshape(nao, nao, nao, nao)
#
#
#    def gaussian_derivative(self, eta, imode, p, q, r=None, s = None):
#        r"""Compute Franck-Condon (or renormalization) derivatives.
#
#        :math:`\pdv{\chi}{\eta}`
#
#        FIXME: check the whether eta has sqrt{\omega/2} or not
#
#        .. math::
#
#           \chi^\al_{pq} = \tt{exp}[-\frac{f^2_\al(\eta_{\al,p}-\eta_{\al,q})^2}{4\om_\al}]
#                         * -\frac{f^2_\al(\eta_{\al,p}-\eta_{\al,q})}{2\om_\al}
#
#        """
#        #derivative = numpy.zeros_like(self.qed.gmat[imode])
#        #nao = derivative.shape[0]
#        diff_eta = (eta[imode, q] - eta[imode, p])
#        if r is not None:
#            diff_eta += (eta[imode, s] - eta[imode, r])
#
#        tmp = 1.0 # self.qed.couplings_var[imode]
#        if False: # depending on wether eta has sqrt(w/2) factors:
#            tmp = tmp / numpy.sqrt(2.0 * self.qed.omega[imode])
#        else:
#            tmp = tmp / self.qed.omega[imode]
#
#        derivative = numpy.exp(-0.5*(tmp*diff_eta)**2) * tmp**2 * diff_eta
#        return derivative
#
#
#    def scf(self, dm0=None, **kwargs):
#        r"""
#        Return total energy of :class:`RHF`.
#
#        Copy of :meth:`hf.SCF.scf <pyscf.scf.hf.SCF.scf>`
#        function, overwritten in :class:`SCRHF` for proper call
#        of :func:`kernel` function in :mod:`~openms.mqed.scqedhf`
#        module.
#
#        Keyword Arguments
#        -----------------
#        dm0 : :class:`~numpy.ndarray`
#            Initial guess density matrix. If not given (the default),
#            the kernel takes the density matrix generated by
#            :external:meth:`~pyscf.scf.hf.SCF.get_init_guess`.
#
#        Returns
#        -------
#        float
#            Electronic energy of last SCF iteration.
#        """
#
#        cput0 = (logger.process_clock(), logger.perf_counter())
#
#        self.dump_flags()
#        self.build(self.mol)
#
#        if self.max_cycle > 0 or self.mo_coeff is None:
#            self.converged, self.e_tot, \
#                    self.mo_energy, self.mo_coeff, self.mo_occ = \
#                    kernel(self, self.conv_tol, self.conv_tol_grad,
#                           dm0=dm0, callback=self.callback,
#                           conv_check=self.conv_check, **kwargs)
#        else:
#            self.e_tot = kernel(self, self.conv_tol, self.conv_tol_grad,
#                                dm0=dm0, callback=self.callback,
#                                conv_check=self.conv_check, **kwargs)[1]
#
#        logger.timer(self, 'SCF', *cput0)
#        self._finalize()
#        return self.e_tot
#    kernel = lib.alias(scf, alias_name='kernel')
#
#
#    def set_params(self, params, fock_shape=None):
#        r"""Reshape Fock after DIIS."""
#        fsize = numpy.prod(fock_shape)
#        f = params[:fsize].reshape(fock_shape)
#
#        etasize = self.eta.size
#        if params.size > fsize:
#            self.eta = params[fsize:fsize+etasize].reshape(self.eta_grad.shape)
#        return f
#
#
#    # SC-QED-HF: only eta.
#    init_var_params = initialize_eta
#    grad_var_params = get_eta_gradient
#
#
#    def norm_var_params(self):
#        var_norm = linalg.norm(self.eta_grad)/numpy.sqrt(self.eta.size)
#        return var_norm
#
#
#    def pre_update_var_params(self):
#        r"""Return variational parameters :math:`\bm{\eta}` and gradients.
#
#        .. note::
#            For SC-QED-HF, :math:`\bm{\eta}` is the only
#            additional variational parameter.
#
#        Return
#        ------
#        variables : :class:`~numpy.ndarray`
#            :math:`\bm{\eta}` values from :attr:`eta`.
#        gradients : :class:`~numpy.ndarray`
#            :math:`\pdv{E}{\bm{\eta}}` values
#            from :attr:`eta_grad`.
#        """
#
#        variables, gradients = self.eta, self.eta_grad
#        return variables, gradients
#
#
#    def update_var_params(self):
#        r"""Update :attr:`eta`."""
#        self.eta -= self.precond * self.eta_grad
#
#
#class SCRKS(dft.rks.KohnShamDFT, SCRHF):
#    r"""Template class for QED-SC-RKS. WIP."""
#    def __init__(
#        self, mol, xc="LDA,VWN", **kwargs):
#        raise NotImplementedError("""RKS object is currently unsupported. WIP.""")
#        #SCRHF.__init__(self, mol, **kwargs)
#        #dft.rks.KohnShamDFT.__init__(self, xc)
#
#    #get_veff = dft.rks.get_veff
#    #get_vsap = dft.rks.get_vsap
#    #energy_elec = dft.rks.energy_elec
#
#
#if __name__ == "__main__":
#    import numpy
#    from pyscf import gto
#
#    itest = 0
#    zshift = itest * 2.0
#
#    atom = f"C    0.00000000    0.00000000    {zshift};\
#             O    0.00000000    1.23456800    {zshift};\
#             H    0.97075033   -0.54577032    {zshift};\
#             C   -1.21509881   -0.80991169    {zshift};\
#             H   -1.15288176   -1.89931439    {zshift};\
#             C   -2.43440063   -0.19144555    {zshift};\
#             H   -3.37262777   -0.75937214    {zshift};\
#             O   -2.62194056    1.12501165    {zshift};\
#             H   -1.71446384    1.51627790    {zshift}"
#
#    mol = gto.M(
#        atom = atom,
#        basis="sto3g",
#        #basis="cc-pvdz",
#        unit="Angstrom",
#        symmetry=True,
#        verbose=1)
#
#    nmode = 1
#    cavity_freq = numpy.zeros(nmode)
#    cavity_freq[0] = 0.5
#    cavity_mode = numpy.zeros((nmode, 3))
#    cavity_mode[0, :] = 0.1 * numpy.asarray([0, 0, 1])
#
#    qedmf = SCRHF(mol, omega=cavity_freq, vec=cavity_mode)
#    qedmf.max_cycle = 500
#    qedmf.kernel()
#    print(f"Electronic energy = {qedmf.e_tot}")


# scqed kernel
def kernel(mf, conv_tol=1e-10, conv_tol_grad=None,
           dump_chk=True, dm0=None, callback=None, conv_check=True, **kwargs):
    '''kernel: the SC-QEDHF and VT-QEDHF SCF driver.

    The major difference against hf kernel is that the one-body and two-body
    integrals are dressed by the photon displacement factors
    and addtional variational parameters eta (for relaxting dipole basis set)
    and variational transformation f are introduced.

    Args:
        mf : an instance of SCF class
            mf object holds all parameters to control SCF.  One can modify its
            member functions to change the behavior of SCF.  The member
            functions which are called in kernel are

            | mf.get_init_guess
            | mf.get_hcore
            | mf.get_ovlp
            | mf.get_veff
            | mf.get_fock
            | mf.get_grad
            | mf.eig
            | mf.get_occ
            | mf.make_rdm1
            | mf.energy_tot
            | mf.dump_chk

    Kwargs:
        conv_tol : float
            converge threshold.
        conv_tol_grad : float
            gradients converge threshold.
        dump_chk : bool
            Whether to save SCF intermediate results in the checkpoint file
        dm0 : ndarray
            Initial guess density matrix.  If not given (the default), the kernel
            takes the density matrix generated by ``mf.get_init_guess``.
        callback : function(envs_dict) => None
            callback function takes one dict as the argument which is
            generated by the builtin function :func:`locals`, so that the
            callback function can access all local variables in the current
            environment.

    Returns:
        A list :   scf_conv, e_tot, mo_energy, mo_coeff, mo_occ

        scf_conv : bool
            True means SCF converged
        e_tot : float
            Hartree-Fock energy of last iteration
        mo_energy : 1D float array
            Orbital energies.  Depending the eig function provided by mf
            object, the orbital energies may NOT be sorted.
        mo_coeff : 2D array
            Orbital coefficients.
        mo_occ : 1D array
            Orbital occupancies.  The occupancies may NOT be sorted from large
            to small.

    Examples:

    >>> from pyscf import gto, scf
    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1', basis='cc-pvdz')
    >>> conv, e, mo_e, mo, mo_occ = scf.hf.kernel(scf.hf.SCF(mol), dm0=numpy.eye(mol.nao_nr()))
    >>> print('conv = %s, E(HF) = %.12f' % (conv, e))
    conv = True, E(HF) = -1.081170784378
    '''
    if 'init_dm' in kwargs:
        raise RuntimeError('''You see this error message because of the API
        updates in pyscf v0.11. Keyword argument "init_dm" is replaced by "dm0"''')
    cput0 = (logger.process_clock(), logger.perf_counter())
    if conv_tol_grad is None:
        conv_tol_grad = numpy.sqrt(conv_tol)
        logger.info(mf, 'Set gradient conv threshold to %g', conv_tol_grad)

    mol = mf.mol
    s1e = mf.get_ovlp(mol)
    if dm0 is None:
        dm = mf.get_init_guess(mol, mf.init_guess)
    else:
        dm = dm0

    # get a initial dm without qed terms
    bare_hf = scf.hf.RHF(mol)

    h1e = bare_hf.get_hcore(mol)
    vhf = bare_hf.get_veff(mol, dm)
    e_tot = mf.energy_tot(dm, h1e, vhf)
    logger.info(mf, 'init E= %.15g', e_tot)

    # Create initial photonic eigenvector guess for each mode
    for a in range(mf.qed.nmodes):
        mf.qed.boson_coeff[a] = mf.qed.update_boson_coeff(e_tot, dm, a)

    mo_energy, mo_coeff =  cholesky_diag_fock_rao(mf, h1e+vhf)
    mo_occ = mf.get_occ(mo_energy, mo_coeff)
    dm = mf.make_rdm1(mo_coeff, mo_occ)
    #logger.debug(mf, "trace of ao_density: %.8f", numpy.trace(dm))

    if mf.qed.use_cs:
        mf.qed.update_cs(dm)

    mf.initialize_var_param(dm)

    # construct h1e, gmat in DO representation (used in SC/VT-QEDHF)
    mf.get_h1e_DO(mol, dm=dm)


    h1e = mf.get_hcore(mol, dm, dress=True)
    vhf = mf.get_veff(mol, dm)
    e_tot = mf.energy_tot(dm, h1e, vhf)
    logger.info(mf, 'init E= %.15g', e_tot)

    scf_conv = False
    mo_energy = mo_coeff = mo_occ = None

    s1e = mf.get_ovlp(mol)
    cond = lib.cond(s1e)
    logger.debug(mf, 'cond(S) = %s', cond)
    if numpy.max(cond)*1e-17 > conv_tol:
        logger.warn(mf, 'Singularity detected in overlap matrix (condition number = %4.3g). '
                    'SCF may be inaccurate and hard to converge.', numpy.max(cond))

    # Skip SCF iterations. Compute only the total energy of the initial density
    if mf.max_cycle <= 0:
        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ

    if isinstance(mf.diis, lib.diis.DIIS):
        mf_diis = mf.diis
    elif mf.diis:
        assert issubclass(mf.DIIS, lib.diis.DIIS)
        mf_diis = mf.DIIS(mf, mf.diis_file)
        mf_diis.space = mf.diis_space
        mf_diis.rollback = mf.diis_space_rollback

        # We get the used orthonormalized AO basis from any old eigendecomposition.
        # Since the ingredients for the Fock matrix has already been built, we can
        # just go ahead and use it to determine the orthonormal basis vectors.
        fock = mf.get_fock(h1e, s1e, vhf, dm)
        _, mf_diis.Corth = mf.eig(fock, s1e)
    else:
        mf_diis = None

    if dump_chk and mf.chkfile:
        # Explicit overwrite the mol object in chkfile
        # Note in pbc.scf, mf.mol == mf.cell, cell is saved under key "mol"
        scf.hf.chkfile.save_mol(mol, mf.chkfile)

    # A preprocessing hook before the SCF iteration
    mf.pre_kernel(locals())

    cput1 = logger.timer(mf, 'initialize scf', *cput0)

    for cycle in range(mf.max_cycle):
        time0 = time.time()
        dm_last = dm
        last_hf_e = e_tot

        time1 = time.time()
        # update h1e in DO
        mf.get_h1e_DO(mol, dm=dm)
        time_h1e_do = time.time() - time1

        # compute gradient of eta
        time1 = time.time()
        mf.get_var_gradient(mf.dm_do, mf.g_dipole, dm=dm)
        time_etagrad = time.time() - time1

        # use DIIS to update eta (in get_fock)
        time1 = time.time()
        h1e = mf.get_hcore(mol, dm, dress=True)
        time_hcore = time.time() - time1

        time1 = time.time()
        fock = mf.get_fock(h1e, s1e, vhf, dm, cycle, mf_diis)
        time_fock = time.time() - time1

        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        dm = mf.make_rdm1(mo_coeff, mo_occ)

        # update energy
        time1 = time.time()
        vhf = mf.get_veff(mol, dm, dm_last, vhf)
        time_veff = time.time() - time1

        h1e = mf.get_hcore(mol, dm, dress=True)
        e_tot = mf.energy_tot(dm, h1e, vhf)

        # Here Fock matrix is h1e + vhf, without DIIS.  Calling get_fock
        # instead of the statement "fock = h1e + vhf" because Fock matrix may
        # be modified in some methods.
        time1 = time.time()
        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        time_fock += time.time() - time1

        norm_gorb = linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))
        if not TIGHT_GRAD_CONV_TOL:
            norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)
        norm_eta = mf.get_var_norm()
        norm_gorb += norm_eta

        norm_ddm = linalg.norm(dm-dm_last)
        logger.info(mf, '\ncycle= %d E= %.15g  delta_E= %4.3g  |g|= %4.3g  |g_var|= %4.3g  |ddm|= %4.3g',
                    cycle+1, e_tot, e_tot-last_hf_e, norm_gorb, norm_eta, norm_ddm)
        logger.debug(mf, "cycle= %d times: h1e_do = %.6g eta_grad = %.6g hcore = %.6g veff = %.6g  fock = %.6g scf = %.6g",
                    cycle+1, time_h1e_do, time_etagrad, time_hcore, time_veff, time_fock, time.time()-time0)

        if callable(mf.check_convergence):
            scf_conv = mf.check_convergence(locals())
        elif abs(e_tot-last_hf_e) < conv_tol and norm_gorb < conv_tol_grad:
            scf_conv = True

        if dump_chk:
            mf.dump_chk(locals())

        if callable(callback):
            callback(locals())

        cput1 = logger.timer(mf, 'cycle= %d'%(cycle+1), *cput1)

        if scf_conv:
            break

    if scf_conv and conv_check:
        # An extra diagonalization, to remove level shift
        #fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        dm, dm_last = mf.make_rdm1(mo_coeff, mo_occ), dm
        vhf = mf.get_veff(mol, dm, dm_last, vhf)

        h1e = mf.get_hcore(mol, dm, dress=True)
        e_tot, last_hf_e = mf.energy_tot(dm, h1e, vhf), e_tot

        fock = mf.get_fock(h1e, s1e, vhf, dm)
        norm_gorb = linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))
        if not TIGHT_GRAD_CONV_TOL:
            norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)
        norm_ddm = linalg.norm(dm-dm_last)

        conv_tol = conv_tol * 10
        conv_tol_grad = conv_tol_grad * 3
        if callable(mf.check_convergence):
            scf_conv = mf.check_convergence(locals())
        elif abs(e_tot-last_hf_e) < conv_tol or norm_gorb < conv_tol_grad:
            scf_conv = True
        logger.info(mf, 'Extra cycle  E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',
                    e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)
        if dump_chk:
            mf.dump_chk(locals())

    logger.timer(mf, 'scf_cycle', *cput0)
    # A post-processing hook before return
    mf.post_kernel(locals())
    return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ


def unitary_transform(U, A):
    r"U^T A U"
    B = numpy.einsum("ik, kj->ij", A, U)
    B = numpy.einsum("ki, kj->ij", U, B)
    return B

def ao2rao(A_ao, P):
    r"""Transforms a matrix from the AO basis to the reduced AO (RAO) basis

    .. math::

       A_{RAO} = P^T A_{AO} P

    where P is the projection onto the linarly independent AO basis
    """

    AP = numpy.einsum("ik, kj->ij", A_ao, P)
    A_rao = numpy.einsum("ik, kj->ij", P.conj().T, AP)
    del AP
    return A_rao

def get_reduced_overlp(L):
    r"""

    .. math::

       S_rao = L L^T

    """
    return numpy.einsum("ik, kj->ij", L, L.conj().T)

def ao2oao(A_ao, X):
    r"""
    Transform a matrix from AO to OAO (orthonormal AO) basis

    .. math::
       A_{OAO} = L^{-1} P^T A_{AO} P L^{-T}
               = X^H A_{AP} X

    where :math:`X^T X = S` and :math:`X` is obtaine from the Cholesky
    decomposition of the AO overlap matrix :math:`S`.

    where .. math::

       P^T S P = L L^T

    is the Cholesky decomposition of the atomic overlap matrix :math:`S`.
    """

    A_oao = reduce(lib.dot, (X.conj().T, A_ao, X))
    return A_oao

def oao2ao(A_oao, X):
    r"""
    Transform a matrix from OAO to AO
    """

    Xinv = linalg.inv(X)
    A_ao = reduce(lib.dot, (Xinv.conj().T, A_oao, Xinv))
    return A_ao

def eigh(h, s):
    '''Solver for generalized eigenvalue problem

    .. math:: HC = SCE
    '''
    e, c = linalg.eigh(h, s)
    #idx = numpy.argsort(e)
    #e = e[idx]
    #c = c[:, idx]
    idx = numpy.argmax(abs(c.real), axis=0)
    c[:,c[idx,numpy.arange(len(e))].real<0] *= -1
    return e, c

def get_orbitals_from_oao(c, P, L):
    r"""
    Sets the orbital coefficients from the orbital coefficients in OAO

       orbital_coefficients = P L^-T C
    """
    X = L.copy()
    X = linalg.inv(X)
    Y = numpy.einsum("ik, kj->ij", X.T, c)
    return numpy.einsum("ik, ij->ij", P, Y)

def get_orbitals_from_rao(c, P):
    r"""
    Sets the orbital coefficients from the orbital coefficients in RAO
       orbital_coefficients = P C
    """
    return numpy.einsum("ik, kj->ij", P, c)

def cholesky_diag_fock_rao(mf, h1e):
    r"""
    Diagonalize the Fock matrix in RAO basis
    """
    F_rao = ao2rao(h1e, mf.P)
    S_rao = get_reduced_overlp(mf.L)
    mo_energy, mo_coeff = eigh(F_rao, S_rao)
    mo_coeff = get_orbitals_from_rao(mo_coeff, mf.P)

    return mo_energy, mo_coeff


def get_fock(
    mf,
    h1e=None,
    s1e=None,
    vhf=None,
    dm=None,
    cycle=-1,
    diis=None,
    diis_start_cycle=None,
    level_shift_factor=None,
    damp_factor=None,
):
    """F = h^{core} + V^{HF}

    Special treatment (damping, DIIS, or level shift) will be applied to the
    Fock matrix if diis and cycle is specified (The two parameters are passed
    to get_fock function during the SCF iteration)

    Kwargs:
        h1e : 2D ndarray
            Core hamiltonian
        s1e : 2D ndarray
            Overlap matrix, for DIIS
        vhf : 2D ndarray
            HF potential matrix
        dm : 2D ndarray
            Density matrix, for DIIS
        cycle : int
            Then present SCF iteration step, for DIIS
        diis : an object of :attr:`SCF.DIIS` class
            DIIS object to hold intermediate Fock and error vectors
        diis_start_cycle : int
            The step to start DIIS.  Default is 0.
        level_shift_factor : float or int
            Level shift (in AU) for virtual space.  Default is 0.
    """
    # copied from hf get_fock, the only difference is that we update h1 in eacy iteration

    mf.initialize_var_param(dm)

    h1e = mf.get_hcore(dm=dm, dress=True)
    if vhf is None:
        vhf = mf.get_veff(mf.mol, dm)

    f = h1e + vhf
    if cycle > -1:
        mf.update_variational_params()

    if cycle < 0 and diis is None:  # Not inside the SCF iteration
        return f

    if diis_start_cycle is None:
        diis_start_cycle = mf.diis_start_cycle
    if level_shift_factor is None:
        level_shift_factor = mf.level_shift
    if damp_factor is None:
        damp_factor = mf.damp
    if s1e is None:
        s1e = mf.get_ovlp()
    if dm is None:
        dm = mf.make_rdm1()

    if 0 <= cycle < diis_start_cycle - 1 and abs(damp_factor) > 1e-4:
        f = damping(s1e, dm * 0.5, f, damp_factor)
    if diis is not None and cycle >= diis_start_cycle:
        #params = diis.update(s1e, dm, f, mf, h1e, vhf)
        variables, gradients = mf.pre_update_params()
        params = diis.update(s1e, dm, f, mf, h1e, vhf, var=variables, var_grad=gradients)
        f = mf.set_params(params, fock_shape=f.shape)
    if abs(level_shift_factor) > 1e-4:
        f = level_shift(s1e, dm * 0.5, f, level_shift_factor)
    return f

class SCRHF(qedhf.RHF):
    r"""Non-relativistic SC-QED-RHF subclass."""
    def __init__(
        self, mol, qed=None, xc=None, **kwargs):

        super().__init__(mol, qed, xc, **kwargs)

        if "scqedhf" not in openms.runtime_refs:
            openms.runtime_refs.append("scqedhf")

        self.eta = numpy.zeros((self.qed.nmodes, self.nao))
        self.eta_grad = numpy.zeros((self.qed.nmodes, self.nao))

        self.mo2dipole = numpy.zeros_like(self.qed.gmat)
        self.ao2dipole = numpy.zeros_like(self.qed.gmat)

        self.bare_fock_ao = numpy.zeros((self.nao, self.nao))
        self.bf_mo_coeff = numpy.zeros((self.nao, self.nao))

        self.eta = None
        self.eta_grad = None
        self.g_dipole = None
        self.precond = 0.1

        # Parameters for dipole moment basis set degeneracy
        self.dipole_degen_e_thresh = 1.0e-8
        self.dipole_fock_shift = 1.0e-3

        #dip_ao2 = lib.einsum("Xuv,Xuv->", self.qed.dipole_ao, self.qed.dipole_ao)
        #log_msg = f"Test: dot(mu_ao, mu_ao) = {dip_ao2}"
        #logger.debug(self, log_msg)

        s1e = self.get_ovlp(mol)
        # matrix for transforming ao to oao
        # oao = X^H * ao * x
        # X^H S X = I or S = X^{-H} X^{-1}
        self.X = scipy_helper.partial_cholesky_orth(s1e, canthr=1.0e-7,
                                                    cholthr=CHOLESKY_THRESHOLD)
        #Xinv = linalg.inv(self.X)
        #print("self.X.shape = ", self.X.shape)
        #print("S = Xinv^H Xinv?", numpy.allclose(S, lib.dot(Xinv.conj().T, Xinv)))

        # Check condition of overlap and e-p interaction matrices
        scipy_helper.remove_linear_dep(self, threshold=1.0e-7, lindep=1.0e-7,
                                       cholesky_threshold=CHOLESKY_THRESHOLD,
                                       force_pivoted_cholesky=FORCE_PIVOTED_CHOLESKY)

        self.L, self.P = mathlib.full_cholesky_orth(s1e, threshold=1.e-7)
        self.n_oao = self.P.shape[1]

        # will replace it with our general DIIS
        self.diis_space = 20
        self.DIIS = diis.SCF_DIIS


#class RHF(qedhf.RHF):
#    # class HF(lib.StreamObject):
#    r"""
#    QEDSCF base class. Non-relativistic RHF.
#
#    :param object mol: molecule object
#    """
#
#    def __init__(self, mol, xc=None, **kwargs):
#        # print headers
#        #logger.info(self, openms.__logo__)
#        if openms._citations["scqedhf"] not in openms.runtime_refs:
#            openms.runtime_refs.append(openms._citations["scqedhf"])
#
#        qedhf.RHF.__init__(self, mol, **kwargs)
#
#        self.eta = None
#        self.eta_grad = None
#        self.g_dipole = None
#        self.precond = 0.1
#
#        logger.debug(self,
#            "\nTest: dot(mu_ao, mu_ao) = %f",
#            lib.einsum("xuv,xuv->", self.qed.dipole_ao, self.qed.dipole_ao),
#        )
#        #
#        self.qed.couplings_var = numpy.ones(self.qed.nmodes)
#        self.qed.update_couplings()
#
#        # save the original one-body integral to save time
#        self.h1e_org = None  # original one-body integral
#        # self.dip_ao = mol.intor("int1e_r", comp=3) # replaced with dipole_ao
#
#
#        # check conditions of overlap and bilinear coupling matrix
#        self._check_and_remove_linear_dep(threshold=1.e-7, lindep=1.e-7,
#                                          cholesky_threshold=CHOLESKY_THRESHOLD,
#                                          force_pivoted_cholesky=FORCE_PIVOTED_CHOLESKY)
#
#        s1e = self.get_ovlp(mol)
#        self.P, self.L = full_cholesky_orth(s1e, threshold=1.e-7)
#        self.n_oao = self.P.shape[1]
#
#        # removing linear dependency
#        #self = remove_linear_dep(self)
#
#        # will replace it with our general DIIS
#        self.diis_space = 20
#        self.DIIS = diis.SCF_DIIS
#        #self.dump_flags()


    def initialize_bare_fock(self, dm = None):
        r"""
        return a bare fock matrix (non-qed) with initial guess dm
        """
        mol = self.mol
        if dm is None:
            dm = super(qedhf.RHF, self).get_init_guess(mol, self.init_guess)

        #h1e = super(qedhf.RHF, self).get_hcore(mol) # bare HF function
        #vhf = super(qedhf.RHF, self).get_veff(mol, dm)
        h1e = scf.hf.get_hcore(mol) # bare HF function
        vhf = scf.hf.get_veff(mol, dm)
        return h1e + vhf

    # get bare MO coefficients
    def get_bare_mo_coeff(self, dm):

        s1e = self.get_ovlp(self.mol)
        #h1e = hf.get_hcore(self.mol)
        #vhf = hf.get_veff(self.mol, dm)
        #fock = hf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        fock = self.initialize_bare_fock(dm)
        mo_energy, mo_coeff = self._eigh(fock, s1e)
        return mo_energy, mo_coeff

    def init_guess_by_1e(self, mol=None):
        if mol is None: mol = self.mol
        logger.info(self, '\nInitial guess from hcore in scqedhf.')
        h1e = self.get_hcore(mol)
        s1e = self.get_ovlp(mol)
        #mo_energy, mo_coeff = self.eig(h1e, s1e)
        mo_energy, mo_coeff =  cholesky_diag_fock_rao(self, h1e)
        mo_occ = self.get_occ(mo_energy, mo_coeff)
        return self.make_rdm1(mo_coeff, mo_occ)

    def _check_and_remove_linear_dep(self, threshold=LINEAR_DEP_THRESHOLD,
                       lindep=LINEAR_DEP_TRIGGER,
                       cholesky_threshold=CHOLESKY_THRESHOLD,
                       force_pivoted_cholesky=FORCE_PIVOTED_CHOLESKY):
        r"""

        """
        max_cond = 0.0
        S = self.get_ovlp()
        scond = numpy.linalg.cond(S)
        if scond > max_cond: max_cond = scond

        for mode in range(self.qed.nmodes):
            gcond = numpy.linalg.cond(self.qed.gmat[mode])
            if gcond > max_cond: max_cond = gcond

        # matrix for transforming ao to oao
        # oao = X^H * ao * x
        # X^H S X = I or S = X^{-H} X^{-1}
        self.X = addons.partial_cholesky_orth_(S, canthr=threshold, cholthr=cholesky_threshold)
        #Xinv = linalg.inv(self.X)
        #print("self.X.shape = ", self.X.shape)
        #print("S = Xinv^H Xinv?", numpy.allclose(S, lib.dot(Xinv.conj().T, Xinv)))

        if max_cond < 1./lindep and not force_pivoted_cholesky:
            logger.info(self, '\nUsing canonical orthogonalization with threshold {}'.format(threshold))
            self._eigh = addons._eigh_with_canonical_orth(threshold)
        else:
            logger.info(self, '\nUsing partial Cholesky orthogonalization '
                    '(doi:10.1063/1.5139948, doi:10.1103/PhysRevA.101.032504)')
            logger.info(self, 'Using threshold {} for pivoted Cholesky'.format(cholesky_threshold))
            logger.info(self, 'Using threshold {} to orthogonalize the subbasis'.format(threshold))
            self._eigh = addons._eigh_with_pivot_cholesky(threshold, cholesky_threshold)


    def ao2mo(self, A):
        r"""Transform AO into MO

        .. math::

            A_{MO} =& C^T_{MO} A_{AO} C_{MO} \\
            A_{pq} =& \sum_{uv} C^T_{pu} A_{uv} C_{vq} = \sum_{pq}
            C^*_{up} A_{uv} C_{vq}, \text{ and } C^T_{pu} = C_{up}

        """
        if self.mo_coeff is None:
            # mo_energy, self.mo_coeff = hf._init_guess_huckel_orbitals(self.mol)
            mo_energy, self.mo_coeff = self.get_bare_mo_coeff(dm)
        Amo = numpy.einsum("uv, vq->uq", A, self.mo_coeff)
        Amo = numpy.einsum("up, uq->pq", self.mo_coeff, Amo)

        return Amo

    def check_n_resolve_degeneracy(self, evals, mo2dipole, dm):
        nmo = mo2dipole.shape[0]
        ediff = 0
        threshold = 1.0e-8
        degeneracy = 1
        degeneracy2 = 1
        shift = 1.0e-3
        for p in range(nmo - 1):
            ediff = evals[p + 1] - evals[p]
            if abs(ediff) < threshold:
                degeneracy += 1
                degeneracy2 += 1
            elif abs(ediff) > threshold and degeneracy > 1:
                r = p + 1 - degeneracy
                s = p + 1

                # get fock in AO with original fock
                fock = self.initialize_bare_fock(dm=dm)  # numpy.zeros((nao, nao))

                # transform into mo
                fock = self.ao2mo(fock)

                # dipole matrix in AO
                r_ao = get_dipole_ao(self.mol, self.qed.add_nuc_dipole)
                sum_dipole_ao = numpy.sum(r_ao, axis=0)
                sum_dipole_mo = self.ao2mo(sum_dipole_ao)

                # plus shift: f_pq += shift * r_pq
                fock += shift * sum_dipole_mo

                # transform into dipole basis
                fock = unitary_transform(mo2dipole, fock)
                deg_fock = fock[r : r + degeneracy, r : r  + degeneracy]

                del sum_dipole_ao, sum_dipole_mo, r_ao
                del fock

                # diagonalize deg_fock
                eig, evecs = linalg.eigh(deg_fock)

                # the basis of the degenerate space --> the new basis
                # new = vector * deg_fock
                vectors = mo2dipole[:, r : s]
                # print(f"deg_fock.shape= {deg_fock.shape} {s-r} {vectors.shape}")
                vectors = numpy.einsum("ik,kj->ij", vectors, evecs)
                mo2dipole[:, r : s] = vectors

                del vectors, deg_fock
                degeneracy = 1

    def get_dm_do(self, dm, U):
        r"""Transform DM from ao to dipole orbital
        """
        s1e = self.get_ovlp(self.mol)
        su = numpy.einsum("ik,kj->ij", s1e, U)
        dm_do = unitary_transform(su, dm)
        del s1e, su
        return dm_do

    def initialize_eta(self, dm):
        r"""Initialize the eta parameters and dipole basis sets
        Ref:
        """

        mo_energy, self.mo_coeff = self.get_bare_mo_coeff(dm)

        nao = self.mol.nao_nr()
        self.eta = numpy.zeros((self.qed.nmodes, nao))
        self.eta_grad = numpy.zeros((self.qed.nmodes, nao))

        # diagonalize the gmat in MO; then get ao2dipole basis transformaiton
        # gmo_tot = numpy.zeros((nao, nao))
        gmo = numpy.zeros_like(self.qed.gmat)  # gmat*sqrt(w/2) in MO
        # print(f"gmo/gmo_toto shapes, {gmo_tot.shape} {gmo.shape}")

        self.ao2dipole = numpy.zeros_like(self.qed.gmat)  # gmat*sqrt(w/2) in MO
        self.mo2dipole = numpy.zeros_like(self.qed.gmat)  # gmat*sqrt(w/2) in MO
        for i in range(self.qed.nmodes):
            gmo[i] = self.qed.gmat[i] * numpy.sqrt(self.qed.omega[i] / 2.0) * self.qed.couplings_var[i]


            gmo[i] = self.ao2mo(gmo[i])  # transform into MO
            # gmo_tot += gmo[i]

            # create dipole basis
            # evals, evecs = linalg.eigh(gmo_tot)
            evals, evecs = linalg.eigh(gmo[i])

            # check degeneracy
            self.check_n_resolve_degeneracy(evals, evecs, dm)
            self.mo2dipole[i] = evecs
            self.eta[i] = evals

            # Creating the basis change matrix from ao to dipole basis
            # i.e., ao2dipole basis transformaiton
            self.ao2dipole[i] = numpy.einsum("ui, ip-> up",
            self.mo_coeff, self.mo2dipole[i])

        # get eri in Dipole basis
        for imode in range(self.qed.nmodes):
            U = self.ao2dipole[imode]
            self.eri_DO = self.construct_eri_DO(U)

#   end of initialize_eta

    def get_eta_gradient(self, dm_do, g_DO, dm=None):
        r"""Compute the gradient of energy with respect to eta.
        Only works for one mode currently:

        .. math::

             \frac{E}{d\eta} = &  \\
                             = &

        """
        nao = self.mol.nao_nr()
        onebody_deta = numpy.zeros(nao)
        twobody_deta = numpy.zeros(nao)

        # 2 * D(p, p) * g(p)
        diagonal_dm_do = numpy.diagonal(dm_do, axis1=1, axis2=2)
        omega_values = self.qed.omega[:, numpy.newaxis]

        # The broadcasting will align the shapes for element-wise operations
        #onebody_deta -= 2.0 * numpy.sum(diagonal_dm_do * g_DO / omega_values, axis=0)

        for p in range(nao):
            for imode in range(self.qed.nmodes):
                onebody_deta[p] -= 2.0 * dm_do[imode, p,p] * g_DO[imode, p] / self.qed.omega[imode]

        for imode in range(self.qed.nmodes):
            fc_derivative = self.gaussian_derivative_vectorized(self.eta, 0)
            tmp1 = 2.0 * self.h1e_DO * dm_do[imode] * fc_derivative
            tmp2 = (2.0 * dm_do[imode].diagonal().reshape(-1, 1) * dm_do[imode].diagonal() \
                   - dm_do[imode] * dm_do[imode].T) \
                   * g_DO[imode].reshape(1, -1) / self.qed.omega[imode]
            onebody_deta += numpy.sum(tmp1 - tmp2, axis=1)
        del fc_derivative, tmp1, tmp2

        fc_derivative = self.gaussian_derivative_vectorized(self.eta, 0, onebody=False)
        fc_derivative *= (2.0 * self.eri_DO - self.eri_DO.transpose(0, 3, 2, 1))
        tmp = lib.einsum('pqrs, rs-> pq', fc_derivative, dm_do[0, :, :], optimize=True)
        twobody_deta = lib.einsum('pq, pq-> p', tmp, dm_do[0, :, :], optimize=True)
        del fc_derivative, tmp

        self.eta_grad[0] = onebody_deta + twobody_deta
        #return onebody_deta + twobody_deta

    # variable gradients, here we only have eta
    get_var_gradient = get_eta_gradient


    def construct_eri_DO(self, U):
        r"""
        Repulsion integral modifier according to dipole self-energy terms
        """
        if self._eri is None:
            self._eri = self.mol.intor("int2e", aosym="s1")

        eri = self._eri.copy()
        nao = self.mol.nao_nr()
        if eri.size == nao**4:
            eri = eri.reshape((nao,)*4)

        # transformation U(u, p) * U(v, q) * U(r, s) * U(t, w) * eri(p, q, r, s) -> eri(u, v, w, t)
        eri = numpy.einsum("pu, qv, rw, st, pqrs->uvwt", U, U, U, U, eri, optimize=True)

        return eri

    # may need to overwrite the fock matrix to define the photon-mediated one-electron
    # part.?
    # Alternatively, we can add the one-electron part in veff, and save
    # the copy, so in the energy calculation, we need to extract the one electron part from
    # the veff

    get_fock = get_fock

    def get_jk(self, mol=None, dm=None, hermi=1, with_j=True, with_k=True, omega=None):
        """get jk matrix in the presence of electron_photon coupling in the coherent state
        representation:

        I_{ijkl} = I^e_{ijkl} + g_{ij}g_{kl}
        where I^e is the pure electronci two-body integral.
        the latter term counts for the photon-mediated correlations

        J_{uv} = \sum_{ls} D_{ls}(uv|ls)
        K_{uv} = \sum_{ls} D_{ls}(us|lv)

        Hence, the photon-mediated part of JK is
        J^p_{uv} = \sum_{ls} D_{ls}(uv|ls) = sum_{ls} D_{ls} g_{uv} g_{ls}
        K^p_{uv} = \sum_{ls} D_{ls} g_{us} g_{lv}

        """
        # Note the incore version, which initializes an _eri array in memory.
        if mol is None:
            mol = self.mol
        if dm is None:
            dm = self.make_rdm1()
            dm = self.get_dm_do(dm, U)

        # add dressing factor to two-body integrals (todo)
        for imode in range(self.qed.nmodes):
            #U = self.ao2dipole[imode]
            factor = self.FC_factor(self.eta, imode, onebody=False)
            eri_tmp = self.eri_DO * factor
            vj, vk = hf.dot_eri_dm(eri_tmp, dm, hermi, with_j, with_k)
            del eri_tmp
        return vj, vk

        # now add contribution from electron-photon coupling residue
        for imode in range(self.qed.nmodes):
            scale_mu = numpy.einsum("ls, ls->", dm, self.gmat[imode])
            vj += scale_mu * self.gmat[imode]
            tmp = numpy.einsum("ls, us->ul", dm, self.gmat[imode])
            vk += numpy.einsum("ul, lv->uv", tmp, self.gmat[imode])

        return vj, vk

    def update_Xuv(self):
        r"""Update X operator

        .. math::

           X_{\mu\nu} = \exp\left[ -\frac{f_\alpha}{\sqrt{2\omega_\alpha}}d^\alpha(a^\dagger_\alpha - a_\alpha) \right]

        """

        print("Update dress operator for electron X_{\mu\nu}")
        factor = numpy.zeros_like(self.gmat)
        print(factor.shape)
        nmode, nao, nao = factor.shape

        # update the renormalization/FC factors (will be moved to FC_factor)
        for imode in range(nmode):
            for p in range(nao):
                for q in range(nao):
                    tmp = self.qed.couplings_var[imode] * (self.eta[imode, p] - self.eta[imode, q])
                    tmp = tmp * tmp / (4.0 * self.qed.omega[imode])
                    factor[imode, p, q] = numpy.exp(-tmp)

    def get_gaussian_factor(self, eta, i, j, k=None, l=None):
        tmp = eta[i] - eta[j]
        if k is not None:
            tmp += eta[k] - eta[l]
        #tmp *= self.qed.couplings_var[imode] # multipy variational transformation parameters
        gaussian_factor = numpy.exp(-0.5 * (tmp / self.qed.omega[0]) ** 2)
        return gaussian_factor

    def FC_factor(self, eta, imode, onebody=True):
        r"""Compute Franck-Condon (or renormalization) factor

        FIXME: check the whether eta has sqrt{\omega/2} or not

        .. math::

           \chi^\alpha_{pq} = \exp[-\frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})^2}{4\omega_\alpha}]

        """
        nao = self.qed.gmat[imode].shape[0]
        if onebody:
            p, q = numpy.ogrid[:nao, :nao]
            diff_eta = eta[imode, p] - eta[imode, q]
            tmp = self.qed.couplings_var[imode]
        else:
            p, q, r, s = numpy.ogrid[:nao, :nao, :nao, :nao]
            diff_eta = eta[imode, p] - eta[imode, q] +  eta[imode, r] - eta[imode, s]
            tmp = 1.0

        tmp = 1.0
        if False: # depending on wether eta has sqrt(w/2) factors:
            tmp = tmp / numpy.sqrt(2.0 * self.qed.omega[imode])
        else:
            tmp = tmp / self.qed.omega[imode]
        factor = numpy.exp(-0.5 * (tmp * diff_eta) ** 2)
        if onebody:
            return factor.reshape(nao, nao)
        else:
            return factor.reshape(nao, nao, nao, nao)

    def gaussian_derivative_vectorized(self, eta, imode, onebody=True):
        nao = eta.shape[1]
        # Calculate diff_eta considering broadcasting
        if onebody:
            p, q = numpy.ogrid[:nao, :nao]
            diff_eta = eta[imode, q] - eta[imode, p]
        else:
            p, q, r, s = numpy.ogrid[:nao, :nao, :nao, :nao]
            diff_eta = eta[imode, q] - eta[imode, p] +  eta[imode, s] - eta[imode, r]

        tmp = 1.0 # self.qed.couplings_var[imode]
        if False:  # Adjust this condition as needed
            tmp /= numpy.sqrt(2.0 * self.qed.omega[imode])
        else:
            tmp /= self.qed.omega[imode]

        # Apply the derivative formula
        derivative = numpy.exp(-0.5 * (tmp * diff_eta) ** 2) * (tmp ** 2) * diff_eta
        if onebody:
            return derivative.reshape(nao, nao)
        else:
            return  derivative.reshape(nao, nao, nao, nao)


    def gaussian_derivative(self, eta, imode, p, q, r=None, s = None):
        r"""Compute Franck-Condon (or renormalization) derivative (/ d\eta)

        FIXME: check the whether eta has sqrt{\omega/2} or not

        .. math::

           \chi^\alpha_{pq} = \exp[-\frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})^2}{4\omega_\alpha}]
                            * - \frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})}{2\omega_\alpha}

        """
        #derivative = numpy.zeros_like(self.gmat[imode])
        #nao = derivative.shape[0]
        diff_eta = (eta[imode, q] - eta[imode, p])
        if r is not None:
            diff_eta += (eta[imode, s] - eta[imode, r])

        tmp = 1.0 # self.qed.couplings_var[imode]
        if False: # depending on wether eta has sqrt(w/2) factors:
            tmp = tmp / numpy.sqrt(2.0 * self.qed.omega[imode])
        else:
            tmp = tmp / self.qed.omega[imode]

        derivative = numpy.exp(-0.5*(tmp*diff_eta)**2) * tmp**2 * diff_eta
        return derivative

    def get_h1e_DO(self, mol=None, dm=None):
        r"""QED variational transformaiton dressed one-body integral.

        .. math::

            h_{uv} = h_{u'v'} \prod_\alpha U^\alpha_{up} U^\alpha_{vq}
                    \exp[-\chi^\alpha_{pq}] U^\alpha_{pu'}U^\alpha_{qv'}

        where

        .. math::

            \chi^\alpha_{pq} = -\frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})^2}{4\omega_\alpha}.

        """
        # considering moving the DSE correciton to this function
        if mol is None:
            mol = self.mol
        if self.bare_h1e is None:
            self.bare_h1e = scf.hf.get_hcore(mol)
        h1e = self.bare_h1e.copy()

        nmode, nao, nao = self.qed.gmat.shape
        self.dm_do = numpy.zeros((nmode, nao, nao))
        if self.g_dipole is None:
            self.g_dipole = numpy.zeros((nmode,nao))

        # FIXME: generalized it to multiple modes
        for imode in range(self.qed.nmodes):

            U = self.ao2dipole[imode]
            self.h1e_DO = unitary_transform(U, h1e)
            gtmp = self.qed.gmat[imode] * numpy.sqrt(self.qed.omega[imode] / 2.0)
            gtmp *= self.qed.couplings_var[imode]
            gtmp = unitary_transform(U, gtmp)

            # one-body operator h1e_pq = h1e_pq + g_pq(p, l) * g_pq(l, p)
            for p in range(nao):
                self.g_dipole[imode, p] = gtmp[p, p] - self.eta[imode, p]
                self.h1e_DO[p, p] += self.g_dipole[imode, p] ** 2 / self.qed.omega[imode]
            del gtmp

            # transform DM from AO to DO
            self.dm_do[imode] = self.get_dm_do(dm, U)

            # Tr[g_pq * D] in DO
            g_dot_D = numpy.diagonal(self.dm_do[imode, :, :]) @ self.g_dipole[imode, :]

    def get_hcore(self, mol=None, dm=None, dress=False):
        r"""QED variational transformaiton dressed one-body integral.

        .. math::

            h_{uv} = h_{u'v'} \prod_\alpha U^\alpha_{up} U^\alpha_{vq}
                    \exp[-\chi^\alpha_{pq}] U^\alpha_{pu'}U^\alpha_{qv'}

        where

        .. math::

            \chi^\alpha_{pq} = -\frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})^2}{4\omega_\alpha}.

        """
        # considering moving the DSE correciton to this function
        if mol is None:
            mol = self.mol
        if self.bare_h1e is None:
            self.bare_h1e = scf.hf.get_hcore(mol)

        if not dress:
            h1e = self.bare_h1e.copy()
        else:
            h1e_DO = self.h1e_DO.copy()
            nmode, nao, nao = self.qed.gmat.shape
            for imode in range(self.qed.nmodes):
                # update the renormalization/FC factors
                # and dress h1e : h_pq  * G_{pq}
                factor = self.FC_factor(self.eta, imode)
                if imode == 0:
                    h1e = numpy.einsum("pq, pq->pq", h1e_DO, factor)
                else:
                    h1e = numpy.einsum("pq, pq->pq", h1e, factor)
            del h1e_DO

            U = self.ao2dipole[0]
            Uinv = linalg.inv(U)
            h1e = unitary_transform(Uinv, h1e)

        return h1e

    # get_veff = get_veff
    def get_veff(self, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1):
        r"""QED Hartree-Fock potential matrix for the given density matrix

        .. math::
            V_{eff} = J - K/2 + \bra{i}\lambda\cdot\mu\ket{j}

        """
        # we also need to update hcore as it's dressed by photon displacement

        if mol is None:
            mol = self.mol
        if dm is None:
            dm = self.make_rdm1()

        nao = self.mol.nao_nr()
        """
        DSE-mediated one-electron parts:

         2 * \title{g}_{pp} * sum_{q} [D_{qq} \title{g}_{qq}]
                                         mean_value
         -D_{qp}\tidle{g}_{pq} * \tilde{g}_{qq} (diagonal element is then g_pq(p)**2)
        """

        imode = 0
        U = self.ao2dipole[imode]
        dm_do = self.get_dm_do(dm, U)

        g_dot_D = numpy.diagonal(dm_do) @ self.g_dipole[imode, :]
        vhf_do = numpy.zeros((nao,nao))

        # vectorized code
        p_indices = numpy.arange(nao)
        vhf_do[p_indices, p_indices] += (2.0 * self.g_dipole[imode, p_indices] * g_dot_D -
                                         numpy.square(self.g_dipole[imode, p_indices]) * dm_do[p_indices, p_indices]) / self.qed.omega[0]

        vhf_do_offdiag = numpy.zeros_like(vhf_do)
        # Calculate off-diagonal elements
        p, q = numpy.triu_indices(nao, k=1)
        vhf_do_offdiag[p, q] -= self.g_dipole[imode, p] * self.g_dipole[imode, q] * dm_do[q, p] / self.qed.omega[0]
        vhf_do_offdiag[q, p] = vhf_do_offdiag[p, q]  # Exploit symmetry
        vhf_do += vhf_do_offdiag

        # vectorized code
        fc_factor = self.FC_factor(self.eta, imode, onebody=False)
        fc_factor *= (1.0 * self.eri_DO - 0.5 * self.eri_DO.transpose(0, 3, 2, 1))
        vhf = 0.5 * lib.einsum('pqrs, rs->pq', fc_factor, dm_do, optimize=True)
        vhf += 0.5 * lib.einsum('qprs, rs->pq', fc_factor, dm_do, optimize=True)
        vhf_do += vhf

        # transform back to AO
        Uinv = linalg.inv(U)
        vhf = unitary_transform(Uinv, vhf_do)

        return vhf

    def get_var_norm(self):
        var_norm = linalg.norm(self.eta_grad)/numpy.sqrt(self.eta.size)
        return var_norm

    def initialize_var_param(self, dm = None):
        r"""
        initialize additional variational parameters
        """
        if self.eta is None:
            #logger.debug(mf, "\n entering initialize bare fock")
            self.initialize_bare_fock(dm)
            self.initialize_eta(dm)

    def update_variational_params(self):
        self.eta -= self.precond * self.eta_grad
        # self.eta -= 0.1 * self.eta_grad

    def pre_update_params(self):
        variables = self.eta
        gradients = self.eta_grad
        return variables, gradients

    def set_params(self, params, fock_shape=None):

        fsize = numpy.prod(fock_shape)
        f = params[:fsize].reshape(fock_shape)
        etasize = self.eta.size
        if params.size > fsize:
            self.eta = params[fsize:fsize+etasize].reshape(self.eta_grad.shape)
        return f

    #kernel = kernel
    def scf(self, dm0=None, **kwargs):

        cput0 = (logger.process_clock(), logger.perf_counter())

        self.dump_flags()
        self.build(self.mol)

        if self.max_cycle > 0 or self.mo_coeff is None:
            self.converged, self.e_tot, \
                    self.mo_energy, self.mo_coeff, self.mo_occ = \
                    kernel(self, self.conv_tol, self.conv_tol_grad,
                           dm0=dm0, callback=self.callback,
                           conv_check=self.conv_check, **kwargs)
        else:
            # Avoid to update SCF orbitals in the non-SCF initialization
            # (issue #495).  But run regular SCF for initial guess if SCF was
            # not initialized.
            self.e_tot = kernel(self, self.conv_tol, self.conv_tol_grad,
                                dm0=dm0, callback=self.callback,
                                conv_check=self.conv_check, **kwargs)[1]

        logger.timer(self, 'SCF', *cput0)
        self._finalize()
        return self.e_tot
    kernel = lib.alias(scf, alias_name='kernel')

# end of scqedhf RHF class

if __name__ == "__main__":
    # will add a loop
    import numpy
    from pyscf import gto, scf

    itest = -2
    zshift = itest * 2.5
    print(f"zshift={zshift}")

    atom = """H 0 0 0; F 0 0 1.75202"""
    atom = f"H          0.86681        0.60144        {5.00000+zshift};\
             F         -0.86681        0.60144        {5.00000+zshift};\
             O          0.00000       -0.07579        {5.00000+zshift};\
             He         0.00000        0.00000        {7.50000+zshift}"

    mol = gto.M(
        atom=atom,
        basis="sto3g",
        #basis="cc-pvdz",
        unit="Angstrom",
        symmetry=True,
        verbose=3,
    )
    print("mol coordinates=\n", mol.atom_coords())

    """
    hf = scf.HF(mol)
    hf.max_cycle = 200
    hf.conv_tol = 1.0e-8
    hf.diis_space = 10
    hf.polariton = True
    mf = hf.run(verbose=4)

    print("electronic energies=", mf.energy_elec())
    print("nuclear energy=     ", mf.energy_nuc())
    dm = mf.make_rdm1()
    """

    print(
        "\n=========== self-consistent SC-QED-HF calculation  ======================\n"
    )

    from openms.mqed import scqedhf as qedhf

    nmode = 1
    cavity_freq = numpy.zeros(nmode)
    cavity_mode = numpy.zeros((nmode, 3))
    cavity_freq[0] = 0.5
    cavity_mode[0, :] = 0.1 * numpy.asarray([1, 1, 1])
    cavity_mode[0, :] = 0.05 * numpy.asarray([0, 0, 1])  # * .1534237789543689328 #* 0.15163914700516712830
    cavity_mode[0, :] = 1.e-1 * numpy.asarray([0, 0, 1])  # * .1534237789543689328 #* 0.15163914700516712830

    mol.verbose = 4

    qedmf = qedhf.RHF(mol, xc=None, cavity_mode=cavity_mode, cavity_freq=cavity_freq, add_nuc_dipole=True)
    qedmf.max_cycle = 500
    qedmf.verbose = 5
    qedmf.init_guess ="hcore"
    qedmf.kernel() #dm0=dm)

    print(f"\n Etot is: {qedmf.e_tot}; ref = ")
