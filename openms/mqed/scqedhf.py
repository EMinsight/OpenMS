#
# @ 2023. Triad National Security, LLC. All rights reserved.
#
# This program was produced under U.S. Government contract 89233218CNA000001
# for Los Alamos National Laboratory (LANL), which is operated by Triad
# National Security, LLC for the U.S. Department of Energy/National Nuclear
# Security Administration. All rights in the program are reserved by Triad
# National Security, LLC, and the U.S. Department of Energy/National Nuclear
# Security Administration. The Government is granted for itself and others acting
# on its behalf a nonexclusive, paid-up, irrevocable worldwide license in this
# material to reproduce, prepare derivative works, distribute copies to the
# public, perform publicly and display publicly, and to permit others to do so.
#
# Author: Yu Zhang <zhy@lanl.gov>
#

import sys
import copy
import numpy
from openms import __config__
from pyscf import lib
from pyscf.scf import hf
from pyscf.dft import rks
#from openms.lib      import logger

from pyscf.lib import logger
#from pyscf.scf import diis
from pyscf.scf import addons
from pyscf.scf import chkfile
from pyscf import __config__
from scipy import linalg

from openms.lib.scipy_helper import partial_cholesky_orth_, pivoted_cholesky
from openms.lib.scipy_helper import remove_linear_dep
from functools import reduce

TIGHT_GRAD_CONV_TOL = getattr(__config__, "scf_hf_kernel_tight_grad_conv_tol", True)
LINEAR_DEP_THRESHOLD = getattr(__config__, 'scf_addons_remove_linear_dep_threshold', 1e-8)
CHOLESKY_THRESHOLD = getattr(__config__, 'scf_addons_cholesky_threshold', 1e-10)
LINEAR_DEP_TRIGGER = getattr(__config__, 'scf_addons_remove_linear_dep_trigger', 1e-10)
FORCE_PIVOTED_CHOLESKY = getattr(__config__, 'scf_addons_force_cholesky', False)


r"""
Theoretical background of SC/VT-QEDHF methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SC-QEDHF module for solving the QED Hamiltonian. The kernel is also used for VT-QEDHF.

"""

# scqed kernel
def kernel(mf, conv_tol=1e-10, conv_tol_grad=None,
           dump_chk=True, dm0=None, callback=None, conv_check=True, **kwargs):
    '''kernel: the SC-QEDHF and VT-QEDHF SCF driver.

    The major difference against hf kernel is that the one-body and two-body
    integrals are dressed by the photon displacement factors
    and addtional variational parameters eta (for relaxting dipole basis set)
    and variational transformation f are introduced.

    Args:
        mf : an instance of SCF class
            mf object holds all parameters to control SCF.  One can modify its
            member functions to change the behavior of SCF.  The member
            functions which are called in kernel are

            | mf.get_init_guess
            | mf.get_hcore
            | mf.get_ovlp
            | mf.get_veff
            | mf.get_fock
            | mf.get_grad
            | mf.eig
            | mf.get_occ
            | mf.make_rdm1
            | mf.energy_tot
            | mf.dump_chk

    Kwargs:
        conv_tol : float
            converge threshold.
        conv_tol_grad : float
            gradients converge threshold.
        dump_chk : bool
            Whether to save SCF intermediate results in the checkpoint file
        dm0 : ndarray
            Initial guess density matrix.  If not given (the default), the kernel
            takes the density matrix generated by ``mf.get_init_guess``.
        callback : function(envs_dict) => None
            callback function takes one dict as the argument which is
            generated by the builtin function :func:`locals`, so that the
            callback function can access all local variables in the current
            environment.

    Returns:
        A list :   scf_conv, e_tot, mo_energy, mo_coeff, mo_occ

        scf_conv : bool
            True means SCF converged
        e_tot : float
            Hartree-Fock energy of last iteration
        mo_energy : 1D float array
            Orbital energies.  Depending the eig function provided by mf
            object, the orbital energies may NOT be sorted.
        mo_coeff : 2D array
            Orbital coefficients.
        mo_occ : 1D array
            Orbital occupancies.  The occupancies may NOT be sorted from large
            to small.

    Examples:

    >>> from pyscf import gto, scf
    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1', basis='cc-pvdz')
    >>> conv, e, mo_e, mo, mo_occ = scf.hf.kernel(scf.hf.SCF(mol), dm0=numpy.eye(mol.nao_nr()))
    >>> print('conv = %s, E(HF) = %.12f' % (conv, e))
    conv = True, E(HF) = -1.081170784378
    '''
    if 'init_dm' in kwargs:
        raise RuntimeError('''You see this error message because of the API
        updates in pyscf v0.11. Keyword argument "init_dm" is replaced by "dm0"''')
    cput0 = (logger.process_clock(), logger.perf_counter())
    if conv_tol_grad is None:
        conv_tol_grad = numpy.sqrt(conv_tol)
        logger.info(mf, 'Set gradient conv threshold to %g', conv_tol_grad)

    mol = mf.mol
    if dm0 is None:
        print("mf.init_guess=", mf.init_guess)
        dm = mf.get_init_guess(mol, mf.init_guess)
    else:
        dm = dm0

    if mf.qed.use_cs:
        mf.qed.update_cs(dm)

    if mf.eta is None:
        mf.initialize_bare_fock(dm)
        mf.initialize_eta(dm)

    # construct h1e, gmat in DO representation
    mf.get_h1e_DO(mol, dm=dm)

    # compute gradient of eta
    mf.get_eta_gradient(mf.dm_do, mf.g_dipole)

    h1e = mf.get_hcore(mol, dm=dm, dress=True)
    vhf = mf.get_veff(mol, dm)

    e_tot = mf.energy_tot(dm, h1e, vhf)
    logger.info(mf, 'init E= %.15g', e_tot)

    scf_conv = False
    mo_energy = mo_coeff = mo_occ = None

    s1e = mf.get_ovlp(mol)
    cond = lib.cond(s1e)
    if numpy.max(cond)*1e-17 > conv_tol:
        logger.warn(mf, 'Singularity detected in overlap matrix (condition number = %4.3g). '
                    'SCF may be inaccurate and hard to converge.', numpy.max(cond))

    # Skip SCF iterations. Compute only the total energy of the initial density
    if mf.max_cycle <= 0:
        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ

    if isinstance(mf.diis, lib.diis.DIIS):
        mf_diis = mf.diis
    elif mf.diis:
        assert issubclass(mf.DIIS, lib.diis.DIIS)
        mf_diis = mf.DIIS(mf, mf.diis_file)
        mf_diis.space = mf.diis_space
        mf_diis.rollback = mf.diis_space_rollback

        # We get the used orthonormalized AO basis from any old eigendecomposition.
        # Since the ingredients for the Fock matrix has already been built, we can
        # just go ahead and use it to determine the orthonormal basis vectors.
        fock = mf.get_fock(h1e, s1e, vhf, dm)
        _, mf_diis.Corth = mf.eig(fock, s1e)
    else:
        mf_diis = None

    if dump_chk and mf.chkfile:
        # Explicit overwrite the mol object in chkfile
        # Note in pbc.scf, mf.mol == mf.cell, cell is saved under key "mol"
        chkfile.save_mol(mol, mf.chkfile)

    # A preprocessing hook before the SCF iteration
    mf.pre_kernel(locals())

    cput1 = logger.timer(mf, 'initialize scf', *cput0)

    for cycle in range(mf.max_cycle):
        dm_last = dm
        last_hf_e = e_tot

        h1e = mf.get_hcore(mol, dm=dm, dress=True)
        fock = mf.get_fock(h1e, s1e, vhf, dm, cycle, mf_diis)
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        dm = mf.make_rdm1(mo_coeff, mo_occ)

        # compute gradient of eta
        mf.get_eta_gradient(mf.dm_do, mf.g_dipole)
        mf.eta -= 0.1 * mf.eta_grad

        # update f_\alpha for vtqed (TODO)

        # update energy
        vhf = mf.get_veff(mol, dm, dm_last, vhf)
        h1e = mf.get_hcore(mol, dm=dm, dress=True)
        e_tot = mf.energy_tot(dm, h1e, vhf)

        # Here Fock matrix is h1e + vhf, without DIIS.  Calling get_fock
        # instead of the statement "fock = h1e + vhf" because Fock matrix may
        # be modified in some methods.
        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        norm_gorb = linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))
        if not TIGHT_GRAD_CONV_TOL:
            norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)
        norm_ddm = linalg.norm(dm-dm_last)
        logger.info(mf, 'cycle= %d E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',
                    cycle+1, e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)

        if callable(mf.check_convergence):
            scf_conv = mf.check_convergence(locals())
        elif abs(e_tot-last_hf_e) < conv_tol and norm_gorb < conv_tol_grad:
            scf_conv = True

        if dump_chk:
            mf.dump_chk(locals())

        if callable(callback):
            callback(locals())

        cput1 = logger.timer(mf, 'cycle= %d'%(cycle+1), *cput1)

        if scf_conv:
            break

    if scf_conv and conv_check:
        # An extra diagonalization, to remove level shift
        #fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        dm, dm_last = mf.make_rdm1(mo_coeff, mo_occ), dm
        vhf = mf.get_veff(mol, dm, dm_last, vhf)

        h1e = mf.get_hcore(mol, dm=dm, dress=True)
        e_tot, last_hf_e = mf.energy_tot(dm, h1e, vhf), e_tot

        fock = mf.get_fock(h1e, s1e, vhf, dm)
        norm_gorb = linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))
        if not TIGHT_GRAD_CONV_TOL:
            norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)
        norm_ddm = linalg.norm(dm-dm_last)

        conv_tol = conv_tol * 10
        conv_tol_grad = conv_tol_grad * 3
        if callable(mf.check_convergence):
            scf_conv = mf.check_convergence(locals())
        elif abs(e_tot-last_hf_e) < conv_tol or norm_gorb < conv_tol_grad:
            scf_conv = True
        logger.info(mf, 'Extra cycle  E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',
                    e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)
        if dump_chk:
            mf.dump_chk(locals())

    logger.timer(mf, 'scf_cycle', *cput0)
    # A post-processing hook before return
    mf.post_kernel(locals())
    return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ


def unitary_transform(U, A):
    r"U^T A U"
    B = numpy.einsum("ik, kj->ij", A, U)
    B = numpy.einsum("ki, kj->ij", U, B)
    return B

def ao_to_reduced_ao(A_ao, P):
    r"""Transforms a matrix from the AO basis to the reduced AO (RAO) basis

    .. math::

       A_{RAO} = P^T A_{AO} P

    where P is the projection onto the linarly independent AO basis
    """

    # TBA
    return None

def ao2oao(A_ao, X):
    r"""
    Transform a matrix from AO to OAO (orthonormal AO) basis

    .. math::
       A_{OAO} = L^{-1} P^T A_{AO} P L^{-T}
               = X^H A_{AP} X

    where :math:`X^T X = S` and :math:`X` is obtaine from the Cholesky
    decomposition of the AO overlap matrix :math:`S`.

    where .. math::

       P^T S P = L L^T

    is the Cholesky decomposition of the atomic overlap matrix :math:`S`.
    """

    A_oao = reduce(lib.dot, (X.conj().T, A_ao, X))
    return A_oao


def oao2ao(A_oao, X):
    r"""
    Transform a matrix from OAO to AO
    """
    Xinv = linalg.inv(X)

    A_ao = reduce(lib.dot, (Xinv.conj().T, A_oao, Xinv))
    return A_ao


# test oao2ao and ao2oao
#F_oao = ao2oao(fock, self.X)
#F_ao = oao2ao(F_oao, self.X)
#print("is F_ao same as original fock?", numpy.allclose(F_ao, fock))


def get_veff(mf, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1, vhfopt=None):
    r"""
    QEDHF Veff construction
    Coulomb + XC functional

    .. note::
        This function will modify the input ks object.

    Args:
        ks : an instance of :class:`RKS`
            XC functional are controlled by ks.xc attribute.  Attribute
            ks.grids might be initialized.
        dm : ndarray or list of ndarrays
            A density matrix or a list of density matrices

    Kwargs:
        dm_last : ndarray or a list of ndarrays or 0
            The density matrix baseline.  If not 0, this function computes the
            increment of HF potential w.r.t. the reference HF potential matrix.
        vhf_last : ndarray or a list of ndarrays or 0
            The reference Vxc potential matrix.
        hermi : int
            Whether J, K matrix is hermitian

            | 0 : no hermitian or symmetric
            | 1 : hermitian
            | 2 : anti-hermitian

    Returns:
        matrix Veff = J + Vxc.  Veff can be a list matrices, if the input
        dm is a list of density matrices.
    """

    # HF veff
    # may implement a universal veff for QEDHF/RKS

    print("debug: qed.get_veff")
    """
    if dm_last is None:
        vj, vk = get_jk(mol, numpy.asarray(dm), hermi, vhfopt)
        return vj - vk * .5
    else:
        ddm = numpy.asarray(dm) - numpy.asarray(dm_last)
        vj, vk = get_jk(mol, ddm, hermi, vhfopt)
        return vj - vk * .5 + numpy.asarray(vhf_last)
    """

    raise NotImplementedError


# we don't need this, only need to define veff
# def get_fock(mf, cav=None, h1e=None, s1e=None, vhf=None, dm=None, cycle=-1, diis=None,
#             diis_start_cycle=None, level_shift_factor=None, damp_factor=None):
#    '''F = h^{core} + V^{HF}
#    cav: cavity object
#
#    '''

def get_fock(
    mf,
    h1e=None,
    s1e=None,
    vhf=None,
    dm=None,
    cycle=-1,
    diis=None,
    diis_start_cycle=None,
    level_shift_factor=None,
    damp_factor=None,
):
    """F = h^{core} + V^{HF}

    Special treatment (damping, DIIS, or level shift) will be applied to the
    Fock matrix if diis and cycle is specified (The two parameters are passed
    to get_fock function during the SCF iteration)

    Kwargs:
        h1e : 2D ndarray
            Core hamiltonian
        s1e : 2D ndarray
            Overlap matrix, for DIIS
        vhf : 2D ndarray
            HF potential matrix
        dm : 2D ndarray
            Density matrix, for DIIS
        cycle : int
            Then present SCF iteration step, for DIIS
        diis : an object of :attr:`SCF.DIIS` class
            DIIS object to hold intermediate Fock and error vectors
        diis_start_cycle : int
            The step to start DIIS.  Default is 0.
        level_shift_factor : float or int
            Level shift (in AU) for virtual space.  Default is 0.
    """
    # copied from hf get_fock, the only difference is that we update h1 in eacy iteration


    h1e = mf.get_hcore(dress=True)
    if vhf is None:
        vhf = mf.get_veff(mf.mol, dm)

    f = h1e + vhf
    if cycle < 0 and diis is None:  # Not inside the SCF iteration
        return f

    if diis_start_cycle is None:
        diis_start_cycle = mf.diis_start_cycle
    if level_shift_factor is None:
        level_shift_factor = mf.level_shift
    if damp_factor is None:
        damp_factor = mf.damp
    if s1e is None:
        s1e = mf.get_ovlp()
    if dm is None:
        dm = mf.make_rdm1()

    if 0 <= cycle < diis_start_cycle - 1 and abs(damp_factor) > 1e-4:
        f = damping(s1e, dm * 0.5, f, damp_factor)
    if diis is not None and cycle >= diis_start_cycle:
        f = diis.update(s1e, dm, f, mf, h1e, vhf)
    if abs(level_shift_factor) > 1e-4:
        f = level_shift(s1e, dm * 0.5, f, level_shift_factor)
    return f


# may be better to implement QEDHF as a HF instance, need to run bare HF first and run QED-HF
# i.e., class HF(hf.SCF)


def dot_eri_dm(eri, dm, hermi=0, with_j=True, with_k=True):
    """Compute J, K matrices in terms of the given 2-electron integrals,
    photon-mediated dressing factor, and density matrix:

    # not done yet, TODO

    J ~ numpy.einsum('pqrs,qp->rs', eri, dm)
    K ~ numpy.einsum('pqrs,qr->ps', eri, dm)

    Args:
        eri : ndarray
            8-fold or 4-fold ERIs or complex integral array with N^4 elements
            (N is the number of orbitals)
        dm : ndarray or list of ndarrays
            A density matrix or a list of density matrices

    Kwargs:
        hermi : int
            Whether J, K matrix is hermitian

            | 0 : no hermitian or symmetric
            | 1 : hermitian
            | 2 : anti-hermitian

    Returns:
        Depending on the given dm, the function returns one J and one K matrix,
        or a list of J matrices and a list of K matrices, corresponding to the
        input density matrices.

    Examples:

    >>> from pyscf import gto, scf
    >>> from pyscf.scf import _vhf
    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1')
    >>> eri = _vhf.int2e_sph(mol._atm, mol._bas, mol._env)
    >>> dms = numpy.random.random((3,mol.nao_nr(),mol.nao_nr()))
    >>> j, k = scf.hf.dot_eri_dm(eri, dms, hermi=0)
    >>> print(j.shape)
    (3, 2, 2)
    """
    return None


def eri_dress(eri, eta=None):
    r"""Dress eri with photon displacements

    eri ~ xx (todo)

    """
    for i in range(nao):
        for j in range(nao):
            fac = i - j

    return None


# inheritance from mqed_hf
from openms.mqed import qedhf
from openms.lib.boson import Photon
import openms

class RHF(qedhf.RHF):
    # class HF(lib.StreamObject):
    r"""
    QEDSCF base class. Non-relativistic RHF.

    :param object mol: molecule object
    """

    def __init__(self, mol, xc=None, **kwargs):
        # print headers
        print(self, openms.__logo__)
        openms.runtime_refs.append(openms._citations["scqedhf"])

        qedhf.RHF.__init__(self, mol, **kwargs)

        self.eta = None
        self.eta_grad = None
        self.g_dipole = None

        self.fac = numpy.ones(self.qed.nmodes)  # variational parameters
        # coherent state parameter
        self.coherentstate = numpy.zeros(self.qed.nmodes)

        # save the original one-body integral to save time
        self.h1e_org = None  # original one-body integral
        # self.dip_ao = mol.intor("int1e_r", comp=3) # replaced with dipole_ao


        # check conditions of overlap and bilinear coupling matrix
        self._check_and_remove_linear_dep(threshold=1.e-7, lindep=1.e-7,
                                          cholesky_threshold=CHOLESKY_THRESHOLD,
                                          force_pivoted_cholesky=FORCE_PIVOTED_CHOLESKY)


        # removing linear dependency
        #self = remove_linear_dep(self)

    def initialize_bare_fock(self, dm = None):
        r"""
        return a bare fock matrix (non-qed) with initial guess dm
        """
        mol = self.mol
        if dm is None:
            dm = super(qedhf.RHF, self).get_init_guess(mol, self.init_guess)

        #h1e = super(qedhf.RHF, self).get_hcore(mol) # bare HF function
        #vhf = super(qedhf.RHF, self).get_veff(mol, dm)
        h1e = hf.get_hcore(mol) # bare HF function
        vhf = hf.get_veff(mol, dm)
        return h1e + vhf

    # get bare MO coefficients
    def get_bare_mo_coeff(self, dm):

        s1e = self.get_ovlp(self.mol)
        #h1e = hf.get_hcore(self.mol)
        #vhf = hf.get_veff(self.mol, dm)
        #fock = hf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        fock = self.initialize_bare_fock(dm)
        mo_energy, mo_coeff = self._eigh(fock, s1e)
        return mo_energy, mo_coeff

    def _check_and_remove_linear_dep(self, threshold=LINEAR_DEP_THRESHOLD,
                       lindep=LINEAR_DEP_TRIGGER,
                       cholesky_threshold=CHOLESKY_THRESHOLD,
                       force_pivoted_cholesky=FORCE_PIVOTED_CHOLESKY):
        r"""

        """
        max_cond = 0.0
        S = self.get_ovlp()
        scond = numpy.linalg.cond(S)
        if scond > max_cond: max_cond = scond

        for mode in range(self.qed.nmodes):
            gcond = numpy.linalg.cond(self.qed.gmat[mode])
            if gcond > max_cond: max_cond = gcond

        # matrix for transforming ao to oao
        # oao = X^H * ao * x
        # X^H S X = I or S = X^{-H} X^{-1}
        self.X = addons.partial_cholesky_orth_(S, canthr=threshold, cholthr=cholesky_threshold)
        #Xinv = linalg.inv(self.X)
        #print("self.X.shape = ", self.X.shape)
        #print("S = Xinv^H Xinv?", numpy.allclose(S, lib.dot(Xinv.conj().T, Xinv)))

        if max_cond < 1./lindep and not force_pivoted_cholesky:
            logger.info(self, '\nUsing canonical orthogonalization with threshold {}'.format(threshold))
            self._eigh = addons._eigh_with_canonical_orth(threshold)
        else:
            logger.info(self, '\nUsing partial Cholesky orthogonalization '
                    '(doi:10.1063/1.5139948, doi:10.1103/PhysRevA.101.032504)')
            logger.info(self, 'Using threshold {} for pivoted Cholesky'.format(cholesky_threshold))
            logger.info(self, 'Using threshold {} to orthogonalize the subbasis'.format(threshold))
            self._eigh = addons._eigh_with_pivot_cholesky(threshold, cholesky_threshold)


    """
    # overwrite the _eigh function with pivoted_cholesky decomposition based eigh
    def _eigh(mf, h, s, threshold=LINEAR_DEP_THRESHOLD,
                                  cholesky_threshold=CHOLESKY_THRESHOLD):
        x = partial_cholesky_orth_(s, canthr=threshold, cholthr=cholesky_threshold)
        xhx = reduce(lib.dot, (x.conj().T, h, x))
        e, c = linalg.eigh(xhx)
        c = numpy.dot(x, c)
        mf.x = x
        return e, c
    """

    '''
    def update_cs(self, dm):
        r"""
        Update coherent state

        .. math::

            z = \langle \bar{g} (=\lambda\cdot\mu) \rangle / \omega = - Tr[D \bar{g}] / \omega
              = - Tr[D g] / \sqrt{2\omega}

        here bilinear interaction \bar{g} is:

        .. math::

            \bar{g}_{pq} = \mu_{pq} * \lambda * \sqrt(\omega/2)

        Note: the difference between :math:`\bar{g}` and :math:`g` is the factor: :math:`\sqrt{\omega/2}`, i.e, g is

        .. math::

            g_{pq} = \mu_{pq} * \lambda
        """

        print("DM(ao) =", numpy.einsum("ij,ij->", dm, dm))
        for imode in range(self.qed.nmodes):
            # gb = self.bilinear_integral(imode)
            trace_gd = lib.einsum(
                "pq, pq ->", dm, self.gmat[imode]
            )  # trace of [gmat * DM]
            print("Trace[gao * DM] =", trace_gd)
            print("g*g =", numpy.einsum("ij,ij->", self.gmat[imode], self.gmat[imode]))
            self.coherentstate[imode] = -trace_gd / numpy.sqrt(
                self.cavity_freq[imode] * 2.0
            )

    '''

    def ao2mo(self, A):
        r"""Transform AO into MO

        .. math::

            A_{MO} =& C^T_{MO} A_{AO} C_{MO} \\
            A_{pq} =& \sum_{uv} C^T_{pu} A_{uv} C_{vq} = \sum_{pq}
            C^*_{up} A_{uv} C_{vq}, \text{ and } C^T_{pu} = C_{up}

        """
        if self.mo_coeff is None:
            loggger.debug(self, " -YZ: mo_coeff is none, initialize it")
            # mo_energy, self.mo_coeff = hf._init_guess_huckel_orbitals(self.mol)
            mo_energy, self.mo_coeff = self.get_bare_mo_coeff(dm)
        Amo = numpy.einsum("uv, vq->uq", A, self.mo_coeff)
        Amo = numpy.einsum("up, uq->pq", self.mo_coeff, Amo)

        return Amo

    def check_n_resolve_degeneracy(self, evals, mo2dipole, dm):
        nmo = mo2dipole.shape[0]
        ediff = 0
        threshold = 1.0e-8
        degeneracy = 1
        degeneracy2 = 1
        shift = 1.0e-3
        for p in range(nmo - 1):
            ediff = evals[p + 1] - evals[p]
            if abs(ediff) < threshold:
                degeneracy += 1
                degeneracy2 += 1
            elif abs(ediff) > threshold and degeneracy > 1:
                # ======================= resolve degeneracy in mo2dipole ==============
                r = p + 1 - degeneracy
                s = p + 1

                # get fock in AO with original fock
                fock = self.initialize_bare_fock(dm=dm)  # numpy.zeros((nao, nao))

                # transform into mo
                fock = self.ao2mo(fock)

                # dipole matrix in AO
                sum_dipole_ao = numpy.sum(self.qed.dipole_ao, axis=0)
                sum_dipole_mo = self.ao2mo(sum_dipole_ao)

                # plus shift: f_pq += shift * r_pq
                fock += shift * sum_dipole_mo

                # transform into dipole basis
                fock = unitary_transform(mo2dipole, fock)
                deg_fock = fock[r : r + degeneracy, r : r  + degeneracy]

                del sum_dipole_ao, sum_dipole_mo
                del fock

                # diagonalize deg_fock
                eig, evecs = linalg.eigh(deg_fock)

                # the basis of the degenerate space --> the new basis
                # new = vector * deg_fock
                vectors = mo2dipole[:, r : s]
                # print(f"deg_fock.shape= {deg_fock.shape} {s-r} {vectors.shape}")
                vectors = numpy.einsum("ik,kj->ij", vectors, evecs)
                mo2dipole[:, r : s] = vectors

                del vectors, deg_fock
                degeneracy = 1
                # ======================= resolve degeneracy (end) ==============

    def get_dm_do(self, dm, U):
        r"""Transform DM from ao to dipole orbital
        """
        s1e = self.get_ovlp(self.mol)
        su = numpy.einsum("ik,kj->ij", s1e, U)
        dm_do = unitary_transform(su, dm)
        del s1e, su
        return dm_do

    def initialize_eta(self, dm):
        r"""Initialize the eta parameters and dipole basis sets
        Ref:
        """

        mo_energy, self.mo_coeff = self.get_bare_mo_coeff(dm)

        nao = self.mol.nao_nr()
        self.eta = numpy.zeros((self.qed.nmodes, nao))
        self.eta_grad = numpy.zeros((self.qed.nmodes, nao))

        # diagonalize the gmat in MO; then get ao2dipole basis transformaiton
        # gmo_tot = numpy.zeros((nao, nao))
        gmo = numpy.zeros_like(self.gmat)  # gmat*sqrt(w/2) in MO
        # print(f"gmo/gmo_toto shapes, {gmo_tot.shape} {gmo.shape}")

        self.ao2dipole = numpy.zeros_like(self.gmat)  # gmat*sqrt(w/2) in MO
        self.mo2dipole = numpy.zeros_like(self.gmat)  # gmat*sqrt(w/2) in MO
        for i in range(self.qed.nmodes):
            gmo[i] = self.gmat[i] * numpy.sqrt(self.qed.omega[i] / 2.0)

            linalg.norm(self.gmat[i]))  # * numpy.sqrt(self.qed.omega[i]/2.0))

            gmo[i] = self.ao2mo(gmo[i])  # transform into MO
            # gmo_tot += gmo[i]

            # create dipole basis
            # evals, evecs = linalg.eigh(gmo_tot)
            evals, evecs = linalg.eigh(gmo[i])

            # check degeneracy
            self.check_n_resolve_degeneracy(evals, evecs, dm)
            self.mo2dipole[i] = evecs
            self.eta[i] = evals

            # Creating the basis change matrix from ao to dipole basis
            # i.e., ao2dipole basis transformaiton
            self.ao2dipole[i] = numpy.einsum("ui, ip-> up",
            self.mo_coeff, self.mo2dipole[i])

        # get eri in Dipole basis
        for imode in range(self.qed.nmodes):
            U = self.ao2dipole[imode]
            self.eri_DO = self.construct_eri_DO(U)

#   end of initialize_eta

    def get_eta_gradient(self, dm_do, g_DO):
        r"""Compute the gradient of energy with respect to eta.
        Only works for one mode currently:

        .. math::

             \frac{E}{d\eta} = &  \\
                             = &

        """
        nao = self.mol.nao_nr()
        onebody_deta = numpy.zeros(nao)
        twobody_deta = numpy.zeros(nao)

        # 2 * D(p, p) * g(p)
        diagonal_dm_do = numpy.diagonal(dm_do, axis1=1, axis2=2)
        omega_values = self.qed.omega[:, numpy.newaxis]

        # The broadcasting will align the shapes for element-wise operations
        #onebody_deta -= 2.0 * numpy.sum(diagonal_dm_do * g_DO / omega_values, axis=0)

        for p in range(nao):
            for imode in range(self.qed.nmodes):
                onebody_deta[p] -= 2.0 * dm_do[imode, p,p] * g_DO[imode, p] / self.qed.omega[imode]


        sum_derivative = 0.0
        for imode in range(self.qed.nmodes):
            for p in range(nao):
                for q in range(nao):
                    fc_derivative = self.gaussian_derivative(self.eta, imode, p, q)
                    if q > p: sum_derivative += fc_derivative
                    onebody_deta[p] += 2.0 * self.h1e_DO[p, q] * dm_do[imode, p, q] * fc_derivative \
                                  - (2.0 * dm_do[imode, q, q] * dm_do[imode, p, p] - dm_do[imode, p, q] \
                                  * dm_do[imode, q, p]) * g_DO[imode, q] / self.qed.omega[imode]

        sum_derivative = 0.0
        # two-electron part
        for p in range(nao):
            for q in range(nao):
                for r in range(nao):
                    for s in range(nao):
                        fc_derivative = self.gaussian_derivative(self.eta, 0, p, q, r=r, s=s)
                        sum_derivative += fc_derivative
                        twobody_deta[p] += (2.0 * self.eri_DO[p, q, r, s] - self.eri_DO[p, s, r, q]) * \
                                        dm_do[0, p, q] * dm_do[0, r, s] * fc_derivative

        return onebody_deta + twobody_deta


    def eri_dipole(self):
        r"""
        Tranform the integrals in the dipole basis.
        via Cholesky decomposition of the repulsion integral matrix.
        Using ao2dipole
        """

        return None

    def construct_eri_DO(self, U):
        r"""
        Repulsion integral modifier according to dipole self-energy terms
        """
        if self._eri is None:
            self._eri = self.mol.intor("int2e", aosym="s1")

        eri = self._eri.copy()
        nao = self.mol.nao_nr()
        if eri.size == nao**4:
            eri = eri.reshape((nao,)*4)

        # transformation U(u, p) * U(v, q) * U(r, s) * U(t, w) * eri(p, q, r, s) -> eri(u, v, w, t)
        eri = numpy.einsum("pu, qv, rw, st, pqrs->uvwt", U, U, U, U, eri, optimize=True)

        return eri

    # may need to overwrite the fock matrix to define the photon-mediated one-electron
    # part.?
    # Alternatively, we can add the one-electron part in veff, and save
    # the copy, so in the energy calculation, we need to extract the one electron part from
    # the veff

    get_fock = get_fock

    def get_jk(self, mol=None, dm=None, hermi=1, with_j=True, with_k=True, omega=None):
        """get jk matrix in the presence of electron_photon coupling in the coherent state
        representation:

        I_{ijkl} = I^e_{ijkl} + g_{ij}g_{kl}
        where I^e is the pure electronci two-body integral.
        the latter term counts for the photon-mediated correlations

        J_{uv} = \sum_{ls} D_{ls}(uv|ls)
        K_{uv} = \sum_{ls} D_{ls}(us|lv)

        Hence, the photon-mediated part of JK is
        J^p_{uv} = \sum_{ls} D_{ls}(uv|ls) = sum_{ls} D_{ls} g_{uv} g_{ls}
        K^p_{uv} = \sum_{ls} D_{ls} g_{us} g_{lv}

        """
        # Note the incore version, which initializes an _eri array in memory.
        if mol is None:
            mol = self.mol
        if dm is None:
            dm = self.make_rdm1()
            dm = self.get_dm_do(dm, U)

        # add dressing factor to two-body integrals (todo)
        for imode in range(self.qed.nmodes):
            U = self.ao2dipole[imode]

            factor = self.FC_factor(self.eta, imode, onebody=False)
            eri_tmp = self.eri_DO * factor
            #vj, vk = hf.dot_eri_dm(eri_tmp, dm, hermi, with_j, with_k)
            vj, vk = hf.dot_eri_dm(self.eri_DO, dm, hermi, with_j, with_k)
            del eri_tmp

        return vj, vk

        """
        if not omega and (self._eri is not None or mol.incore_anyway or self._is_mem_enough()):
            if self._eri is None:
                self._eri = mol.intor("int2e", aosym="s8")

            # derssing two-body integral
            vj, vk = hf.dot_eri_dm(self._eri, dm, hermi, with_j, with_k)
        else:
            # print(" -YZ: omega is not none!", omega)
            vj, vk = RHF.get_jk(self, mol, dm, hermi, with_j, with_k, omega)
        """

        # now add contribution from electron-photon coupling residue
        for imode in range(self.qed.nmodes):
            scale_mu = numpy.einsum("ls, ls->", dm, self.gmat[imode])
            vj += scale_mu * self.gmat[imode]
            tmp = numpy.einsum("ls, us->ul", dm, self.gmat[imode])
            vk += numpy.einsum("ul, lv->uv", tmp, self.gmat[imode])

        return vj, vk

    def update_Xuv(self):
        r"""Update X operator

        .. math::

           X_{\mu\nu} = \exp\left[ -\frac{f_\alpha}{\sqrt{2\omega_\alpha}}d^\alpha(a^\dagger_\alpha - a_\alpha) \right]

        """

        print("Update dress operator for electron X_{\mu\nu}")
        factor = numpy.zeros_like(self.gmat)
        print(factor.shape)
        nmode, nao, nao = factor.shape

        # update the renormalization/FC factors (will be moved to FC_factor)
        for imode in range(nmode):
            for p in range(nao):
                for q in range(nao):
                    tmp = self.fac[imode] * (self.eta[imode, p] - self.eta[imode, q])
                    tmp = tmp * tmp / (4.0 * self.qed.omega[imode])
                    factor[imode, p, q] = numpy.exp(-tmp)

    def get_gaussian_factor(self, eta, i, j, k=None, l=None):
        tmp = eta[i] - eta[j]
        if k is not None:
            tmp += eta[k] - eta[l]
        #tmp *= self.fac[imode] # multipy variational transformation parameters
        gaussian_factor = numpy.exp(-0.5 * (tmp / self.qed.omega[0]) ** 2)
        return gaussian_factor

    def FC_factor(self, eta, imode, onebody=True):
        r"""Compute Franck-Condon (or renormalization) factor

        FIXME: check the whether eta has sqrt{\omega/2} or not

        .. math::

           \chi^\alpha_{pq} = \exp[-\frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})^2}{4\omega_\alpha}]

        """
        nao = self.gmat[imode].shape[0]
        if onebody:
            factor = numpy.zeros((nao, nao))
            for p in range(nao):
                for q in range(p, nao):
                    tmp = self.fac[imode] * (eta[imode, p] - eta[imode, q])
                    if False: # depending on wether eta has sqrt(w/2) factors:
                        tmp = tmp / numpy.sqrt(2.0 * self.qed.omega[imode])
                    else:
                        tmp = tmp / self.qed.omega[imode]
                    factor[p, q] = numpy.exp(-0.5*tmp**2)
                    #print("dress factor=", p, q, tmp)
                    if q > p: factor[q, p] = factor[p, q]
            return factor
        else:
            factor = numpy.zeros((nao, nao, nao, nao))
            for p in range(nao):
                for q in range(p, nao):
                    for r in range(nao):
                        for s in range(r, nao):
                            tmp = self.fac[imode] * (eta[imode, p] - eta[imode, q] + eta[imode, r] - eta[imode, s])
                            if False: # depending on wether eta has sqrt(w/2) factors:
                                tmp = tmp / numpy.sqrt(2.0 * self.qed.omega[imode])
                            else:
                                tmp = tmp / self.qed.omega[imode]
                            tmp = numpy.exp(-0.5*tmp**2)
                            factor[p, q, r, s] = factor[q, p, r, s] = factor[p, q, s, r] = factor[q, p, s, r] = tmp
            return factor


    def gaussian_derivative(self, eta, imode, p, q, r=None, s = None):
        r"""Compute Franck-Condon (or renormalization) derivative (/ d\eta)

        FIXME: check the whether eta has sqrt{\omega/2} or not

        .. math::

           \chi^\alpha_{pq} = \exp[-\frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})^2}{4\omega_\alpha}]
                            * - \frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})}{2\omega_\alpha}

        """
        derivative = numpy.zeros_like(self.gmat[imode])
        nao = derivative.shape[0]
        diff_eta = (eta[imode, q] - eta[imode, p])
        if r is not None:
            diff_eta += (eta[imode, s] - eta[imode, r])

        tmp = self.fac[imode]
        if False: # depending on wether eta has sqrt(w/2) factors:
            tmp = tmp / numpy.sqrt(2.0 * self.qed.omega[imode])
        else:
            tmp = tmp / self.qed.omega[imode]

        derivative = numpy.exp(-0.5*(tmp*diff_eta)**2) * tmp**2 * diff_eta
        return derivative


    def get_h1e_DO(self, mol=None, dm=None):
        r"""QED variational transformaiton dressed one-body integral.

        .. math::

            h_{uv} = h_{u'v'} \prod_\alpha U^\alpha_{up} U^\alpha_{vq}
                    \exp[-\chi^\alpha_{pq}] U^\alpha_{pu'}U^\alpha_{qv'}

        where

        .. math::

            \chi^\alpha_{pq} = -\frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})^2}{4\omega_\alpha}.

        """
        # considering moving the DSE correciton to this function
        if mol is None:
            mol = self.mol
        if self.h1e_org is None:
            self.h1e_org = hf.get_hcore(mol)
        h1e = self.h1e_org.copy()

        nmode, nao, nao = self.gmat.shape
        self.dm_do = numpy.zeros((nmode, nao, nao))
        if self.g_dipole is None:
            self.g_dipole = numpy.zeros((nmode,nao))

        # FIXME: generalized it to multiple modes
        for imode in range(self.qed.nmodes):

            U = self.ao2dipole[imode]
            h1e = unitary_transform(U, h1e)
            gtmp = self.gmat[imode] * numpy.sqrt(self.qed.omega[imode] / 2.0)
            gtmp = unitary_transform(U, gtmp)

            # one-body operator h1e_pq = h1e_pq + g_pq(p, l) * g_pq(l, p)
            for p in range(nao):
                self.g_dipole[imode, p] = gtmp[p, p] - self.eta[imode, p]
                h1e[p,p] += self.g_dipole[imode, p] ** 2 / self.qed.omega[imode]

            # #U * U [factor] U * U
            # h1e = numpy.einsum("pu, qv, pq, pm, qn, mn-> uv", U, U, factor[imode], U, U, h1e, optimize=True)

            del gtmp

            # transform DM from AO to DO
            self.dm_do[imode] = self.get_dm_do(dm, U)

            # Tr[g_pq * D] in DO
            #g_dot_D = numpy.dot(numpy.diagonal(self.dm_do[imode, :, :]), self.g_dipole[imode, :])
            g_dot_D = numpy.diagonal(self.dm_do[imode, :, :]) @ self.g_dipole[imode, :]

            # h1e in dipole basis
            self.h1e_DO = h1e

    def get_hcore(self, mol=None, dm=None, dress=False):
        r"""QED variational transformaiton dressed one-body integral.

        .. math::

            h_{uv} = h_{u'v'} \prod_\alpha U^\alpha_{up} U^\alpha_{vq}
                    \exp[-\chi^\alpha_{pq}] U^\alpha_{pu'}U^\alpha_{qv'}

        where

        .. math::

            \chi^\alpha_{pq} = -\frac{f^2_\alpha(\eta_{\alpha,p}-\eta_{\alpha,q})^2}{4\omega_\alpha}.

        """
        # considering moving the DSE correciton to this function
        if mol is None:
            mol = self.mol
        if self.h1e_org is None:
            self.h1e_org = hf.get_hcore(mol)

        if not dress:
            h1e = self.h1e_org.copy()
        else:
            h1e_DO = self.h1e_DO.copy()
            nmode, nao, nao = self.gmat.shape
            for imode in range(self.qed.nmodes):
                # update the renormalization/FC factors
                # and dress h1e : h_pq  * G_{pq}
                factor = self.FC_factor(self.eta, imode)
                if imode == 0:
                    h1e = numpy.einsum("pq, pq->pq", h1e_DO, factor)
                else:
                    h1e = numpy.einsum("pq, pq->pq", h1e, factor)
            del h1e_DO

            U = self.ao2dipole[0]
            Uinv = linalg.inv(U)
            h1e = unitary_transform(Uinv, h1e)

        return h1e

    # get_veff = get_veff
    def get_veff(self, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1):
        r"""QED Hartree-Fock potential matrix for the given density matrix

        .. math::
            V_{eff} = J - K/2 + \bra{i}\lambda\cdot\mu\ket{j}

        """
        # we also need to update hcore as it's dressed by photon displacement

        if mol is None:
            mol = self.mol
        if dm is None:
            dm = self.make_rdm1()

        nao = self.mol.nao_nr()
        """
        DSE-mediated one-electron parts

         2 * \title{g}_{pp} * sum_{q} [D_{qq} \title{g}_{qq}]
                                         mean_value
         -D_{qp}\tidle{g}_{pq} * \tilde{g}_{qq} (diagonal element is then g_pq(p)**2)
        """

        imode = 0
        U = self.ao2dipole[imode]
        dm_do = self.get_dm_do(dm, U)

        g_dot_D = numpy.diagonal(dm_do) @ self.g_dipole[imode, :]
        vhf_do = numpy.zeros((nao,nao))
        for p in range(nao):
            vhf_do[p, p] += (2.0 * self.g_dipole[imode, p] * g_dot_D -
                            self.g_dipole[imode, p] ** 2 * dm_do[p, p]) / self.qed.omega[0]

            for q in range(p+1, nao):
                fc = self.get_gaussian_factor(self.eta[imode], p, q)
                vhf_do[p, q] -= self.g_dipole[imode, p] * self.g_dipole[imode, q] \
                                * dm_do[q, p] / self.qed.omega[0]
                vhf_do[q, p] = vhf_do[p, q]
        #

        # construct vj vk in dpole
        if self._eri is not None or not self.direct_scf:
            vj, vk = self.get_jk(mol, dm_do, hermi)
            vhf = vj - vk * 0.5
        else:
            ddm = numpy.asarray(dm) - numpy.asarray(dm_last)
            ddm = self.get_dm_do(ddm, U)
            vj, vk = self.get_jk(mol, ddm, hermi)
            vhf = vj - vk * 0.5
            vhf += numpy.asarray(vhf_last)

        # transform back to AO
        vhf += vhf_do

        Uinv = linalg.inv(U)
        vhf = unitary_transform(Uinv, vhf)

        # one electron part (residue for VT-QEDHF)
        self.oei = self.qed.add_oei_ao(dm) * 0.0 # this is zero for scqedhf
        vhf += self.oei

        return vhf

    def dump_flags(self, verbose=None):
        return hf.RHF.dump_flags(self, verbose)

    def dse(self, dm):
        r"""
        compute dipole self-energy
        """
        dip = self.dip_moment(dm=dm)
        # print("dipole_moment=", dip)
        e_dse = 0.0
        e_dse += 0.5 * numpy.dot(self.qed.z_lambda, self.qed.z_lambda)

        print("dipole self-energy=", e_dse)
        return e_dse

    def energy_tot(self, dm=None, h1e=None, vhf=None):
        r"""Total QED Hartree-Fock energy, electronic part plus nuclear repulstion
        See :func:`scf.hf.energy_elec` for the electron part

        Note this function has side effects which cause mf.scf_summary updated.
        """

        # update h1e as well
        # h1e = self.get_hcore(dress=True)

        nuc = self.energy_nuc()
        e_tot = self.energy_elec(dm, h1e, vhf)[0] + nuc

        #e_tot += 0.5 * numpy.einsum("pq,pq->", self.oei, dm)
        #dse = self.dse(dm)  # dipole sefl-energy
        #e_tot += dse

        self.scf_summary["nuc"] = nuc.real
        return e_tot

    """
    def get_jk(self, mol=None, dm=None, hermi=1, with_j=True, with_k=True,
               omega=None):
        # Note the incore version, which initializes an _eri array in memory.
        #print("debug-zy: qed get_jk")
        if mol is None: mol = self.mol
        if dm is None: dm = self.make_rdm1()
        if (not omega and
            (self._eri is not None or mol.incore_anyway or self._is_mem_enough())):
            if self._eri is None:
                self._eri = mol.intor('int2e', aosym='s8')
            vj, vk = hf.dot_eri_dm(self._eri, dm, hermi, with_j, with_k)
        else:
            vj, vk = SCF.get_jk(self, mol, dm, hermi, with_j, with_k, omega)

        # add photon contribution, not done yet!!!!!!! (todo)
        # update molecular-cavity couplings
        vp = numpy.zeros_like(vj)

        vj += vp
        vk += vp
        return vj, vk
    """

    kernel = kernel

    def post_kernel(self, envs):
        r"""
        Use the post kernel to print citation informations
        """
        breakline = '='*80
        logger.info(self, f"\n{breakline}")
        logger.info(self, f"*  Hoollary, the job is done!\n")
        logger.info(self, f"Citations:")
        for i, citation in enumerate(openms.runtime_refs):
            logger.info(self, f"[{i+1}]. {citation}")
        logger.info(self, f"{breakline}\n")


# end of scqedhf RHF class

class RKS(rks.KohnShamDFT, RHF):
    def __init__(self, mol, xc="LDA,VWN", **kwargs):
        RHF.__init__(self, mol, **kwargs)
        rks.KohnShamDFT.__init__(self, xc)

    def dump_flags(self, verbose=None):
        RHF.dump_flags(self, verbose)
        return rks.KohnShamDFT.dump_flags(self, verbose)

    get_veff = rks.get_veff
    get_vsap = rks.get_vsap
    energy_elec = rks.energy_elec


# class RKS(rks.RKS):
#
#    def __init__(self, mol, xc=None, **kwargs):
#        print("debug- DFT driver is used!")
#        print("xc=", xc)
#        rks.RKS.__init__(self, mol, xc=xc)
#
#        cavity = None
#        if "cavity" in kwargs:
#            cavity = kwargs['cavity']
#            if "cavity_mode" in kwargs:
#                cavity_mode = kwargs['cavity_mode']
#            else:
#                raise ValueError("The required keyword argument 'cavity_mode' is missing")
#
#            if "cavity_freq" in kwargs:
#                cavity_freq = kwargs['cavity_freq']
#            else:
#                raise ValueError("The required keyword argument 'cavity_freq' is missing")
#
#            print('cavity_freq=', cavity_freq)
#            print('cavity_mode=', cavity_mode)
#
#        print(f"{cavity} cavity mode is used!")
#
#    def dump_flags(self, verbose=None):
#        return rks.RKS.dump_flags(self, verbose)


if __name__ == "__main__":
    # will add a loop
    import numpy
    from pyscf import gto, scf

    itest = -2
    zshift = itest * 2.5
    print(f"zshift={zshift}")

    atom = """H 0 0 0; F 0 0 1.75202"""
    atom = f"H          0.86681        0.60144        {5.00000+zshift};\
        F         -0.86681        0.60144        {5.00000+zshift};\
        O          0.00000       -0.07579        {5.00000+zshift};\
        He         0.00000        0.00000        {7.50000+zshift}"

    mol = gto.M(
        atom=atom,
        basis="sto3g",
        #basis="cc-pvdz",
        unit="Angstrom",
        symmetry=True,
        verbose=3,
    )
    print("mol coordinates=\n", mol.atom_coords())

    """
    hf = scf.HF(mol)
    hf.max_cycle = 200
    hf.conv_tol = 1.0e-8
    hf.diis_space = 10
    hf.polariton = True
    mf = hf.run(verbose=4)

    print("electronic energies=", mf.energy_elec())
    print("nuclear energy=     ", mf.energy_nuc())
    dm = mf.make_rdm1()
    """

    print(
        "\n=========== self-consistent SC-QED-HF calculation  ======================\n"
    )

    from openms.mqed import scqedhf as qedhf

    nmode = 1
    cavity_freq = numpy.zeros(nmode)
    cavity_mode = numpy.zeros((nmode, 3))
    cavity_freq[0] = 0.5
    cavity_mode[0, :] = 0.1 * numpy.asarray([1, 1, 1])
    cavity_mode[0, :] = 0.05 * numpy.asarray([0, 0, 1])  # * .1534237789543689328 #* 0.15163914700516712830
    cavity_mode[0, :] = 1.e-1 * numpy.asarray([0, 0, 1])  # * .1534237789543689328 #* 0.15163914700516712830

    mol.verbose = 4

    qedmf = qedhf.RHF(mol, xc=None, cavity_mode=cavity_mode, cavity_freq=cavity_freq, add_nuc_dipole=True)
    qedmf.max_cycle = 500
    qedmf.verbose = 5
    #qedmf.init_guess ="hcore"
    qedmf.kernel() #dm0=dm)

